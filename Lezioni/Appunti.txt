CLASSE INTERNA
se una classe viene utilizzata solo in una classe e non esternamente, allora si crea una classe interna(all interno della classe che la utilizza metto una definizione privata di classe)
CLASSE INTERNA ANONIMA
lo stesso discorso di prima ma nella classe esterna si chama il new sull interfaccia(bottone.addActionListener(new ActionListener())), dunque evito di dichiarare la classe perche viene creata un istanza della classe anonima che implenta l interfaccia.
ADAPTER 
adatta i metodi da implementare in modo tale che la classe che implementa l interfaccia non debba implementare tutti i metodi
FACADE(strutturali)
dp strutturale serve per organizzare i metedi dei business componet in facciate in modo tale che i controller debbano interagire solo con le poche facciate e non i molteplici businnes componet
	1 creare bs comp
BUILDER(creazionale)
nasconde l implementazione dell oggetto, più restrittivo rispetto alla factory
utile perche le proprietà sei sicuro di averle incapsulate e l oggetto viene creatocon caratteristiche predefinite 
metodi di creazione : Product, AbstractBuilder(costruisce e definisce le parti del prodotto) ConcreteBuilder(assembla), Director gestiste le istanze dei prodotti che devono essere istanziati
--------------------------------------------------------------
pattern creazionale
LAZY INIZIALIZATION
si istanzia l oggetto, lo si pozina in una struttura dati in modo che poi si richiama senza inizializzarlo di nuovo.

-------------------------------------------------------------------
METODOLOGIA AGILE
---------------------------------------------------------------
WATERFALL(cascata)
V model
Plan       Analisi      design       build        test        deploy
-plan : high level technial design, costi, punti critici
- analisi : casi d'uso e diagramma di sequenza
-design : gli sviluppatori prendono i documenti di specifica e bisogna disegnare il diagrammma delle classi
-build  
	a)preparazione del componet test
		quali metodi vanno testati, quali dati servono
	b)build effettivo
	c)esecuzione component test
		junit: verifico ogni omponente
-test
	-esecuzione assemly test
	- system test
	-performace test
	- uat(user accepted test): conformità a diversi standard

---------------------------------------

Che cos è il testing? è un modo per controllare i requisiti e constatare che sono state soddisfatte le aspettative.
V-MODEL : ogni cosa a sinistra vinee testata a destra, ogni fase deve essere conclusa prima di iniziare la successiva
assembly test verifica il desegno dettagliato
component test- verifica i dettaglia 
AGILE
non ci sono più ruoli precisi all interno del progetto
sprint: modo con la quale si chiama il rilascio dei progetti

COS'E UNA COLLECTION
Una struttura dati che serve per contenere riferimenti ad altri oggetti(gli array possono contenere oggetti e dati primitivi)
Gerarchia delle collezioni
--------------------------------INTERFACE
Iterable(fornisce metodi iterator)
Collection(caratteristiche di base come:
List 		Set 		Queue 	                   Map
------------------------------------ CLASSI
List:simili ad array
- ArrayList - > ArrayList<Integer>  vantaggio di mettere il tipo: controllo negli insermenti, e recupero(evita casting) FIFO
- LinkedList -> LinkedList: doppia coda (posso inserire da testa e estrarre da coda, e viceversa) permette tanto ma pesante
- Vector/Stack -> simile a arraylist LIFO

COSA VUOL DIRE CHE SONO DINAMICI? 
dimensione:n elementi che vado ad aggiungere(.size)
Capacità: celle preallocate per definire una collection(se non specifico nulla in fase di inizializzazione è 10, una volta superato si cancella la vecchia lista e se ne crea una nuova con capacità doppia) occhio alla memoria (!!LA CAPACITà NON SI PUò DIMINUIRE)



!! ArrayList estende AbstractArrayList
IMPLEMENTA 
- List
- RandomAccess -> tecnica che viene utilizzata in prog, per accedere in maniara diretta agli indici (tramite un sistema binario)
- Serializable -> prendere tutto l' oggetto e lo salva in memoria
- Clonable -> danno la possibilità di utilizzare il dp "Prototype"
MIGLIORE perche simula l'array, dunque veloce , grazie a RANDOM ACCESS

METODI

lista.trimToSize() serve per ottimizzare la cacità una volta finito l'inserimento
clear() pulisce tutto
isEmpty()
set(int index,Object)
remove(Object) , remove(index)
ensureCapacity()
get(int)
indexOf(Object)
LastIndexOf(Obj)
addAll(lista2) // mette in coda
lista.toArray()
contains(obj) 

COMPARATOR
classe che implementa Comparator<Obj>
si utilizza il suo metodo compare(obj o1, obj o2) se di overraida il metodo 
in modo da gestire il modo con cui si vuole ordinare l'array con oggetti complessi
return se positivo o1 maggiore di o2, negativo il contrario, 0 se uguali
(si puo usare anche con gli array)

INTERNO
comparazione in fase di avviamento
ESTERNO
di volta in volta posso scegliere come organizzare i dati


!!LINKEDLIST
ESTENDE AbstractSequentialList
IMPLEMENTA List, Deque, Clonable, Serializable
molto piu lenta di ArrayList(no randonAccess)

			Head 				Tail
METODI	       throwExcTE   !throwExcNTE   	throwExc     !throwExc
insert		addFirst     offerFirst        addLast       offerLast
remove         removeFirst   pollFirst         removeLast    pollLast
examine         getFirst      peekFirst          getLast       peekLast
Iterator (next e previous)
ListIterator<tipo> iterator = linkedlist.listIterator(posizione da cui partire, 
	0 sottointeso, da ultimo: linkedlist.size(), oppure indice es:40);
DescendingIterator


CONFRONTO CON QUEUE E STACK
QUEUE(coda)FIFO
METODI				Deque
add			TE	addLast
offer		 	NTE	offerLast
remove 			TE	removeFirst
poll 			NTE	pollFirst
element 		TE	getFirst
peek          		NTE	peekFirst

STACK(Pila/LIFO)*	 Deque
push			addFirst
pop			removeFirst
peek			getFirst
*le eccezione devono essere sempre gestite


!!VECTOR  estende AbstractArrayList
IMPLEMENTA 
- List
- RandomAccess -> tecnica che viene utilizzata in prog, per accedere in maniara diretta agli indici (tramite un sistema binario)
- Serializable -> prendere tutto l' oggetto e lo salva in memoria
- Clonable -> danno la possibilità di utilizzare il dp "Prototype"
simile a arrayList
THREADSAFE : garantiscono un sistema di gestione di sincronizzazione dei thread
t1			t2
	Arraylist
0			0
1			1
2			3
3			4
4			1000
5
6
1000
problema:concorrenza dei thread
rischio di stallo
SINCRONIZZARE I THREAD: in questo caso funziona in modo sequenziale, prima finisce uno e poi il sistema operativo permette operazioni all altro

- - - 
Stack estende Vector
--------------------------------------------------------

SET:dati unici all'interno
-HashSet, LinkedHashSet, TreeSet, EnumSet

NON PREVEDE DATI DUPLICATI

HASHSET<>()
ESTENDE AbstractSet
IMPLEMENTA Set, Clonable, Seriaziable

CONCURRENTSKIPLISTSET(Versione sincronizzata del treeset)

- - - - - - - - - -  -
LINKEDHASHSET<>()
ESTENDE HASHSET
IMPLEMENTA Set, Clonable, Seriaziable

Mantiene l'ordine di inserimento dati e offre più metodi
- - - - - - - - - - -  -
TREESET
primo valore:Route
Se il valore da inserire è minore della route allora va alla sinistra della route, destra altrimenti
Treeset implementa NavigableSet(mantiene i dati perfettamente ordinati all interno della struttura)

METODI
set.headSet(valore) -> restituisce tutti i valori minori di 50
set.tailSet(valore) -> restituisce tutti i valori maggiori di 50
subSet(x, y)

- - - - - - - - - - - - 
EnumSet

--------------------------------------------------------------
Queue: logica di inserimento della coda
-LinkedList, PriorityQueue
INTERFACCIA,  FIFO

Implementata :
Queue<String> coda = new PriorityQueue<String>();
Queue<String> coda = new LinkedList<String>();

THREADSAFE -> Queue<String> coda = new PriorityBlockingQueue<String>();
PriorityQueue non mantiene i dati in base all inserimento, ma è la chiave di hashing che da la posizione nella struttura,
dunque io posso organizzare i dati come voglio io(come nei comparatori)

--------------------------------------------
Map:Capacità base  16
-HashMap, TreeMap, LinkedHasMap, HashTable

chiave(user_n)		valore
mimmo			dati_sessione
luigi
3
4
5			oggetto

HASHMAP estende map
capacità default 16
veloce ma non mi interessa l ordine

LINKEDHASHMAP
mantiene l ordine delle chiavi come le ho inserite

TREMAP
chiavi perfettamente ordinate

HASHTABLE
Struttura sincronizzata delle mappe

METODI
containsKey(chiave)
put(chiave, oggetto)
get(chiave)
keySet() -> set delle chiavi
remove(chiave)
size()
values() ->  Collection dei valori
isEmpty()
clear()
containsValue(oggetto)
--------------------------------------------


COLLECTION
METODO
.min(lista)
.max(lisat)
.shuffle(lista) // mischia
.binarySearch(lista)
.sort(lista, Collection.ReverseOrder());
.frequency(lista, elemento) ->
.copy(l_destianzione, lista_riferimento)
.addAll(l1, l2)
.fill(lista1, elemento)
.disjoint(list1, list2); -> ritorna true se disgiunte


---------------------------------------------------------------
21/10/2020

SERIALIZZAZIONE
ObjectInputStream
ObjectOutputStream
interfacce per gestire il processo di serializzazione
rendono i dati illegibili a meno di deserializzazione

modificatore: TRANSIENT
collegato a processo seriazzazione che scrive l oggetto intero
se non voglio scrivere un campo di istanza allora metto transient su campo istanza.

serialVersionUID : un timbro di riconoscimento, utile per il processo di deserializzazione


-------------------------------------------------------------------------------------
DECOLLECTOR -> DP STRUTTURALE
ad una base si aggiungono a runtime dei decoratori

COMPOSITE -> DP STRUTTURALE
organizzare la struttura ad albero per semplificare la gestione delle foglie

BRIDGE -> DP STRUTTURALE
permette di separare in maniera netta l astrazione della classe dalla sua classe astratto interfaccia
separa l ereditarietà dall evoluzione di astrazione

QUALE PROBLEMA DI TROPPA EREDITARIETA'
i progetti subiscono modifiche continue, componenti con troppa dipendenza creano probelmi a cascata

PROXY -> DP STRUTTURALE
quando ci sono metodi pesanti che richiedono tanto tempo PROXY rende possibile istanziare solo quando si chiama il metodo

MEMENTO -> COMPORTAMENTALE
mantenere lo stato degli oggetti che vengono istanziati
COMPOSTO DA:
Memento : oggetto da salvare
Originator: memorizza gli stati
CareTaker : ripristina gli stati

LISTENER
fornisce risultati in base ad eventi


-------------------------------------------------
26/10/2020
DATABASE RELAZIONALI
DMBS
basato su entità che comunicano tramite relazioni(no duplicati)
RDBMS
def: (conforme)segue le 12 regole definite da codd
meccanismi di INTEGRITA' REFERENZIALE
controllo su parser(strumento che analizza e compila le query) che verifica l integrità dei 
dati su tutti i punti di vista
BLOCCA QUALSIASI VIOLAZIONE DI VINCOLI
COME SI CREA UN DB RELAZIONALE?
FASI DI NOMRMALIZZAZIONE (sono 5)
1 -> FASE ATOMICA : dividere i dati per argomenti(nelle stesse tabelle) in modo 
			da non avere duplicati
2 -> DEFINIZIONE RELAZIONE TRA TABELLE : inserire campo fondamentale (PRIMARY KEY)
			pk è un vincolo, serve per creare relazioni come: 
		tipi di relazioni con pk: 1 a 1, 1 a molti
		CARATTERISTICHE PK
			- UNICA(inserendo pk si genera vincolo Unique)
			- NOT NULL
			- AUTOMATICAMENTE INDICIZZATA
-------------------------------------------------------------
1 A MOLTI
Un record della prima tabella è collegat a tanti della seconda,
un record della seconda è collegato a uno solo della prima. (cliente -> ordini)

RAGIONAMENTO
prendo la pk del cliente e la ripeto negli ordini
cliente			ordine
idCliente	  idOrdine   IdCliente

-----------------------------------------------------------------
FOREING KEY(chiave esterna)
punto di legame per definire una relazione uno a molti
la pk di clienti prende il nome di foreing key
-----------------------------------------------------------------------
RELAZIONE MOLTI A MOLTI
creo tabella aggiuntiva (ordine -> registrazione -> prodotto)

ordine			registrazione		Prodotto
idOrdine        |   idReg  idOrd  idProd     |  idProd


  1  create table iscrizione(
  2  id_iscrizione int,
  3  id_corso int,
  4  id_corsista int,
  5  constraint p_idiscrizione primary key(id_iscrizione),
  6  constraint f_idcorso foreign key(id_corso) references corso(id_corso),
  7  constraint f_idcorsista foreign key(id_corsista) references corsista(id_corsista),
  8* constraint u_controllo unique(id_corso, id_corsista))
--------------------------------------------------------------------------------------------
RELAZIONI UNO A UNO
associare due pk tra loroquesy oer creare relazioen unoa uno

SQL> create table impiegato(
  2  id_imp int,
  3  nome_imp varchar2(30),
  4  p_idimp primary key(id_imp));

Tabella creata.

SQL> create table dati_aziendali(
  2  id_imp int primary key references impiegato(id_imp),
  3  data_assunzione date);

create table pagamenti(
id_prog int primary key references progetto(id_prog),
costo int,
data_pagamento date)
/
--------------------
c
3 -> SCORPORARE IN NUOVE ENTITA'
	se puoi dividere un entita in altre entita si può fare
	
RAGIONAMENTO:
basta che ci sia qualcosa che identifichi qualcosaltro è necessario fare un latra entità
ma bisogna classificare le entita in base all appartenenza(citta e cap di una persona
sono dati anagrafici, non entità citta)



INDICIZZATA!!
Indice = oggetto creato sul db
Scopo -> entry ordinato per una o più colonne in modo da trovare in modo efficiente il dato

id	nome	cognome		INDEX TABLE (in memoria PGA)
1				1	
2				2
3				3
5				4
6

Select * from Cliente, Ordine
where cliente.idcliente = ordine.idcliente;

CHE DIFFERENZA?
da uno leggiamo da disco, in una leggiamo da unità di memoria

in una tabella i campi candidati all indicizzazione possono dipendere dalla query:
se un campo è parametro di una query fatto 200 volte al minuto allora indicizzazione utile


OLTP				
db generico
usato sia per interrogazioni che per modiica
NON SI ESAGERA CON GLI INDICI -> se modifico un dato si deve andare a ricreare le indextable
a livello di query bene, ma peso a livello di modifiche(tante modelle da ridefinire)	

SCHEMA:
Esiste tabella centrale collegata con relazioni ad altre tabelle(NO RELAZIONI MULTIPLE)


OLAP (Datawarehouse)
PBOLAP tabelle costruite su dati tridimentisionali
SOLO INTERROGATO (quasi tutti i campi sono indicizzati, perche non modifico i dati)
Strumento di analisi

SCHEMA
Esistono "DATAMARK" e una centrale "TABELLA DEI FATTI"


TRANSAZIONE IN DB RELAZIONALE
E' una serie di operazioni dml che rimangono in unità di memoria (rollback segment) finche non si decide
di concludere l operazione tramite un "commit" oppure annullare tutto


COMANDI DML(data manipolation language)
1)insert -> 10 righe prima di db si salvano su unità mem Rollback Segment
		a)commit: chiude svuota e salva 	b)rollback:chiude svuota cancella
2)update -> update tabella set 
		campo = valore | espressione | (subquery)
		campo = valore | espressione | (subquery)
		where cond;
3)delede -> abilita il rolback -> delete from tabella where filter;

DIZIONARIO DATI
Mantiene tutti i dati che noi scriviamo, in modo da tenere uno storico 

COMANDI DDL
!!!AUTOCOMMITTANTI!!! ->prima di creare un oggeto il comando deve concludere la transazioen
Creazione dati
1) create table -> commit


DCL(permessi)
TCL(transaction)
DQL(data query l)

CRUD

ORACLE SQL
-----------------------------------
/    : esegue l ultimo comando nel buffer
l    : dice quale comando ce nel buffer
column : formatta le colonne della tabella
.      :mi cancella la query sbagliata

----------------------------------
SQL> create table prova(i int);

Tabella creata.

SQL> save C:\Users\betacom\Desktop\Accademy\SQLquery\ddl.sql
Creato file C:\Users\betacom\Desktop\Accademy\SQLquery\ddl.sql
SQL> drop table prova cascade constraints;

Tabella eliminata.

SQL> @ C:\Users\betacom\Desktop\Accademy\SQLquery\ddl.sql

Tabella creata.


ABBIAMO SALVATO SU FILE UNA QUERY E CON LA CHIOCCIOLA ABBIAMO CARICATO LE QUERY CONTENUTE IN 
UN FILE ALL INTERNO DEL PROMPT
--------------------------------------------------------------------------

TIPI DI DATI DI SQL
 
Stringa

char			lung. fissa	(43 char) significa 43 caratteri non B 		2000B	1char = 1B
varchar	 		lung. variabile  2000
varchar2 		lung. variabile  4000 (prende la dimensione in base a quanti caratteri inserisco)
long varchar -> 	max 2GB ( dim variabile) (inseribile solo una volta)
clob -> 		aggiornamento di long varchar (4GB)
bclob -> 		4GB possibilità di scrivere con caratteri multi-Byte

diff char/varchar
char ottimizza le prestazioni, ma non ottimizza le locazioni di spazio char(5) inserisco 201 = 201_ _
varchar ottimizza lo spazio, si deve fare valutazine dinamica della stringa
-------------------------------------------------------------------------
number(5) -> 99999 : 	5 precizione
number(5,2) -> 999.99 : 2 scala

int/smallint/integer -> number(38)

double

float
---------------------------------- 

Date
ing :"2000-JEN-01"
ita :"12-GEN-2000"
alter system/session set nls_date_language = 'AMERICAN';
timestap(6) default 6, max 9 
-----------------------------------------
Binari

raw  		-> 2000B

long raw 	-> 2GB
		
blob  		->  parte da 4GB  a 128 TB
sqlloader utility che permette di convertire un file -> bin
-------------------------------------------------------------
Anagrafica

create table nome(
campo tipo constraint,
campo tipo constraint,
campo tipo constraint) tablespace Anagrafica;

tblspc default: User01.dbf

tablespace è un datafile (.dbf) che contiene gli oggetti che noi creaiamo all interno del db

create tablespace Nome
datafile ........
.........
;

Schema -> turbo
In oracle unità logica che suddivide in oggetti
uno schema con nome 
è suddiviso in oggetti
table	view	sequence	procedure	trigger		functions

create table  turbo.impiegato tablespace nome;
select * from turbo.impiegato

tutto regolato da permessi

-----------------------------------------------------

se vuoi copiare lo schema ma non i dati si fa
create table nome as select * from corso where 1 = 2;

CONSTRAINT SULLO SCHEMA

primary key
come:
1) id int primary key
2)id int,
......
....,
constraint p_id primary (id)); //migliore
- - - - - - - - - - - -- - - - - - - - - - - - 
foreign key
come:
1)constraint f_nome foreign key(campo) references tab(campo)

2)nome tipo foreign key(campo) references tab(campo)
on delete cascade
// quando volgio cancellare i record collegati in una tablla quando elimino un suo dato
--------------------------------------------------------
check
si impostano condizioni sul campo, ma condizioni molto semplici(es. data inizio < data fine)
------------------------------------------------------------
unique
constraint u_nome unique(campo, campo2)
-------------------------------
not null

!!!!!!!!
'' -> stringa vuota DIVERSA null
-------------------------------------------------
default
nome tipo default val
!! per inserire il valore di default non devo nemmeno inserire null!!

 create table esempiodefault (
   id int,
   livello number(1) default 5)


NO :insert into esempiodefault values(1,null);
SI :insert into esempiodefault(id) values(3);

----------------------------------------------
DDL (auto commit)
create
drop tipo nome;
drop table nome cascade constraint; (elimina anche tabelle collegate)
alter table nome ......; -> modifica contenuto tabella
rename nomeV to nome
truncate table nome / delete from nomeT -> elimina i contenuti della tabella
	DDL		DML
comment -> commenti

ROW LEVEL BLOCK
su transazioni concorrenti, gli altri utenti non possono modificare i dati finche 
una transazione non viene chiusa

------------------------------------------
come funziona alter table

alter table nomeT add(nomec tipo, costraint tipo, ........)
modify(nomec tipo, constraint tipo,)
drop nomec / constraint :elimina una cosa per volta

ESEMPI
1) alter table prova rename column note to nota;
2) alter table prova modify(nota not null);
3) rename prova to prove;
4) alter table prove add(note varchar2(100)) modify(nota varchar2(50));
5) alter table prova add(constraint p_i primary key(i));
6) alter table prove drop primary key;
7) alter table prove disable primary key
8) alter table prove enable primary key
---------------------------------------------
comment

1) comment on table prove is 'MIMMO CE';
2) COMMENT ON COLUMN PROVE.NOTA IS 'ciaparat colonna';
3)desc user_tab_comments
  select comments from user_tab_comments where table_name = 'PROVE';

--------------------------------------------------
LISTE
Gerarchie:
DBA [dba_tables]  : vedo oggetti di tutti gli utenti
ALL [all_tables]  : vedo tutti gli oggetti che mi appartengono e gli ogetti su cui ho permessi di lettura
USER [user_tables]: vedo solo oggetti che mi appartengono

user_views
user_procedures
user_triggers
user_synonyms
---------------------------------------------------
SEQUENZE
è un oggetto che viene creato che permette di creare in automatico la progressione numerica degli id
e vantaggio che valore l posso usare dove voglio(non solo come pk)
UTILILE PER UTILIZZARE SQL DA JAVA
(non possono descrementare, partono da almeno 1)
presenta psudocolonne

create sequence idseq_seq
1) insert into u_sequenza values(idseq_seq.nextval,'max');
2) insert into u_sequenza values(idseq_seq.nextval,'paolo');
3) select * from u_sequenza;
ID NOME
---------- -----------
         1 max
         2 paolo
         3 paola


TABELLA 'DUAL'
tabella di oracle per testare le funzioni
si adatta a qualsiasi funzionalita
es. select 5+5 from dual;
es. select user from dual;
-------------------------------------------------------
PL/SQL : 'procedure language sql'

linguaggio proprietario di oracle
utilizzato per scrivere ROUTINE:
1) procedure
2) trigger
3) funcion

- - - - - - - ----------------------------------------------
PROCEDURE
se voglio esegure func sql ma voglio mettere delle condizioni, o eseguirle in modo
iterativo servono le procedure
vengono riciamate sql cmd -> execute nome(..) (da qualsiasi lng di prog -> {call nome(...)})

-----------------------------------------------------------------------------
TRIGGER
componenti che partono in base ad eventi(es.listener)
before >	corpo eseguito prima che l istruzione DML modifichi idati
after > 	contrario
instead of > 	corpo del trigger sostituisce istr DML

QUANTE VOLTE ESEGUO TRIGGER
statement > corpo eseguito una sola volta per evento
riga > corpo eseguino n volte in base a quante righe sono modificate dall istr DML


OPERATORI DI CORRELAZIONE
riferimenti particolari che fanno riferimento ai valori(vecchi nuovi) 
:new  -> prende il valore dopo esecuzione
:old  -> prende il valore prima dell esecuzione del trigger


select ... into ... -> PL/SQL = CURSORE

ESEMPIO
SQL> create or replace trigger generaseq
  2  before insert on u_sequenza
  3  for each row
  4  begin
  5  select idseq_seq.nextval into :new.id
  6  from dual;
  7  end;
  8  /

Trigger creato.

----------------------------------------
FUNCTION
ritorna un valore
vs procedure faccio -> select calcolo from tab ;
chiamata dentro la query

(on replace -> sostituisce l ogget sistente)
------------------------------------------------------------------------------------------
COMANDI DCL(Data Control Language)
- grant
- revoke

SINTASSI
- grant ruolo, privilegio, priv2, priv3 to ruolo/public/schema; (grant dba to turbo)
	
	creare ruolo nomer;
	grant select any table, drop any trigger, alter any table to nomer;
	grante nomer to turbo;	

	create user turbo identified psw; -> non ha privilegi ma anche se fosse
	non puo creare oggetti(necessita di quote di scrittura)
	dunque
	quota 100M on nomeTableSpace quota unlimited on t2
	default tablespace nomeT temporary tablespace
	with admin option

- revoke  ruolo, privilegio, priv2, priv3 from ruolo/public/schema;
----------------------------------------------------------------


QUERY
3 fasi
1) analisi
2) compilazione
3) fetch

[NB : il parser compila una sola volta la query]

costruzione query:
select campo[default: all]
from tab
where cond
order by

PER VEDERE TEMPO > set timing on
NON VOGLIO DUPLICATI > distinct
TUTTI I CAMPI > *

WHERE:
- campo = val
- campo is null [nell update ci va =]
- not
- and
- or
- xor
- != / <> [diverso]
- =
- betweem val1 and val2 [estremi compresi]
- in('Milano','Torino','Roma','Treviso') equivale campo = 'Milano' or 'Torino ...
- like 'A%' inizia con a e contiene n caratteri qualsiasi
- like 'E%RA_' inizia con e
- exists(subquery) -> il parser prima di compilare controlla se la subquery ritorna delle righe
- cond any(tab) -> se valore è cond di ogni valore contenuto in tab
- campo1 || ' ' || campo2   > concatena 

FUNZIONI DI RAGGRUPPAMENTO
- max
- min
- avg
- stddev
- variance
- count
- sum

HAVING -> pone delle condioni come where ma sul modo di raggruppare

EQUIJOIN
permette di selezionare i record correlati dall esecuzione di una select
regola:non interessa l ordine dei campi

OTTIMA PER ORACLE
select nome_imp, nome_rep
from impiegato2, reparto
where
impiegato2.id_rep = reparto.id_rep

CLASSICA
select impiegato2.nome_imp,reparto.nome_rep
from reparto
inner join impiegato2 on(impiegato2.id_rep = reparto.id_rep)
-----
SE CAMPI COLLEGAMENTO HANNO STESSO NOME

INNER JOIN:
select impiegato2.nome_imp,reparto.nome_rep
from reparto
inner join impiegato2 using(id_rep)

o
NATURAL JOIN:
select impiegato2.nome_imp,reparto.nome_rep
from reparto
natural join impiegato2
------------------------------------------------------------
OUTER JOIN
selezione i record anche non correlati (campo a destra deve avere la tabella della quale voglio i record)

ORACLE:
select nome_imp, nome_rep
from impiegato2, reparto
where
impiegato2.id_rep (+)= reparto.id_rep

UNA SECONDA OPZIONE

LEFT JOIN (from da tab con pk)
select impiegato2.nome_imp,reparto.nome_rep
from reparto
left join impiegato2 on(impiegato2.id_rep = reparto.id_rep)

RIGHT JOIN(from da tab con fk)
select impiegato2.nome_imp,reparto.nome_rep
from impiegato2 
right join reparto on(impiegato2.id_rep = reparto.id_rep)

FULL OUTER JOIN 
controlla per ogni tabella i campi non correlati

CROSS JOIN
select impiegato2.nome_imp,reparto.nome_rep
from reparto, impiegato2
cross join impiegato2

SET JOIN

select 'Il libro ' || titolo || 'Š il'||level||'della serie'||serie as "Gerarchia libri"
from libri
start with parent_id is null connect by prior is isbn = parent_id


QUERY PARAMETRICHE
query che al posto del valore ha un parametro variabile
utile perche la query è compilata una volta
es.  select * from reparto where nome_rep = &reparto;

QUERY INSIEMISTICHE

1-UNION / UNION ALL[si duplicati]
SQL> r
  1  select nome_cliente, citta_cliente, societa, tipologia
  2  from clienti2
  3  union / intersect / minus
  4  select nome_fornitore,citta_fornitore,societa, tipologia
  5  from fornitori
  6* order by tipologia

2-INTERSECT > dati comuni
3-MINUS -> dati non in comune


FUNIZONI DI CONVERSIONE
-to_number
-to_date
-to_char

data solo in to_char
FLAG TO_CHAR(per date)
- MM
- MONTH
- MON
- YY
- YYYY
- HH24
- HH12
- AM_PM
- MI
- SS

FLAG TO NUMBER
- 9  -> 999,999,999,999.00 (dove 9 qualsiasi roba
- 0
- .
- ,
- MI > messo in fondo se val negativo mette - in fondo al number
- V > 999V99 = n° a sx elevato alla seconda (999V999 n^3 ecc..)

esempio:
1)	SQL> select nome_progetto
 	 2  from progetti
 	 3  where to_char(data_inizio,'yyyy') > '2005';

2)	SQL> select to_char(122999, '999,999,999.00') from dual;
3) 	SQL> select nvl(to_char(stipendio),'Stipendio non presente') from dipendente;


- FUNC CONVERSIONE
- FUNC STRINGA
	SQL> SELECT initcap('max') from dual; -> 'Max'
	SQL> select upper('max') from dual; -> 'MAX'	
	SQL> select length('davcavcahb') from dual; -> 12
	SQL> select replace('Funzione replace','ne','ni') from dual; -> 'Funzioni replace'
	SQL> select substr('Funzine substring',10,6) from dual;
	SQL> select trim('        as') from dual; -> 'as'
	SQL> select ltrim('        as       ') from dual; -> 'as        '
	SQL> select rtrim('        as       ') from dual; -> '        as'
	SQL> select instr('tommasosancini@gmail.com','@') from dual; -> 15

- FUNC DATE
	SQL> select sysdate + interval '10-3' year to month from dual;
	SQL> select sysdate - interval '0-3' year to month from dual;
	SQL> select to_char(sysdate + interval '1-6' year to month + interval '5 02:10:30' day to second,
		'DD-MM-YYYY HH24:MI:SS') as calcolo from dual;

	SQL> alter session set nls_date_format = 'YYYY-MM-DD'; (customizzo il fromato della data)
	SQL> select systimestamp from dual; -> molto preciso
	SQL> select months_between('19-NOV-2001','16-OTT-2010') from dual; -> differenza tra mesi 
- FUNC NUMERICHE
	SQL> select abs(-20) from dual; > MODULO
	SQL> select round(3000.2345242,2) from dual; > truncate + arrotondamento
	SQL> select trunc(3000.2345242,2) from dual;
	SQL> select ceil(3000.2345242) from dual;
	SQL> select floor(3000.2345242) from dual;
	SQL> select log(4,2) from dual;
	SQL> select mod(5,2) from dual;
	SQL> select sign(-20) from dual;
	SQL> select sqrt(25) from dual;
	SQL> select power(4,25) from dual;


----------------------------------------------------------------------
VIEWS 
SELEZIONI DINAMICHE 
un modo di salvare le query (RIMANE SALVATA COME OGGETTO NEL DB)
NON CONTIENE DATI PROPRI

creare View:	SQL> create or replace view selezione
 	 		2  as select * from imp;

eseguire view:	SQL> select * from selezione;
----------------------------------------------------
QUERY SU FILE
SALVARE QUERY :    SQL> save C:\Users\betacom\Desktop\Accademy\SQLquery\selezione.sql
ESEGUIRE QUERY  :  SQL> @C:\Users\betacom\Desktop\Accademy\SQLquery\selezione.sql
VEDERE CONTENUTO : SQL> get C:\Users\betacom\Desktop\Accademy\SQLquery\selezione.sql
---------------------
INSERIMENTO VIEW

INSERISCO CAMPO UNO PER VOLTA : SQL> insert into tab values(null, null, x, null,x); 
Inserisco solo i campi che mi servono : SQL> insert into tab(campo1, campo4, campo8,) values(......);
ma ogni volta devo riscrivere quindi:

INSERT VIEW(maschera di inserimento)
1)creo view
	create or replace view insert_tab
	as select campo,campo4, campo8   
	from tab;

2)inserisco nella tab tramite view 	
	insert into insert_tab values(........);

nella view posso fare inserimenti in una tabella per volta per non 
bypassare l integrita referenziale
(solo tramite trigger a puntino si puo fare view aggiornabili)

NO! create view Nome as
    select cliente.id, nome_cliente, ordine.id
    from cliente, ordine.

---ESEMPIO----
a) create or replace view acco
  2  as
  3  select avg(acconto) as a
  4  from prenot
  5  group by cod_alb;

b) select clienti.nome || clienti.cognome || clienti.citta as anagrafica,alberghi.nome,prenot.acconto
  2  from clienti,alberghi,prenot,acco
  3  where clienti.id=prenot.cod_cli and prenot.cod_alb=alberghi.cod_alb
  4* and acconto>a
--------------------------------------------------------------------------------
ORACLE - SINONIMI
Oggetti che servono per memorizzare un sinonimo per un oggetto

create synonym nome_sy for nomeOggetto;

problema -> select * from tabelledimassimo.cliente;
soluzione -> create synonym cliente for tabelledimassimo.cliente;
		select * from cliente
POSSONO ESSERE
public : create synonym cliente for tabelledimassimo.cliente;
privati : create synonym paolo.cliente for tabelledimassimo.cliente;

----------------------------------------------------------
DATABASE LINK
link a un istanza di un db esterno

COME
create database link miolink
connect ruolo(presente in db2) identified by psw
using db2;

QUERY
select * from cliente@miolink

COMANDI TCL(Transaction control language)
- commit;
- rollback;
- savepoint (punti di ripristino all interno di una transazione) -> rollback to nome_sp
- set autocommit on;
- set transaction !!!!!
	
ISOLATION LEVEL > modalita ce viene usata per interagire con trans di altri client
	- default : Read Committed (altro client legge solo se committato) (no dirty read)
	- Read uncommitted (no Oracle)
	- read only (posso fare letture ripetibili)
	- serializable (come read only ma permette dele modifiche)
		posso modificare dati che non sono stati gia toccatai da altri client(anche da trensazioni commitatte)
-------------------------------------------------------------------------
PROBLEMI CONCORRENZA
- DIRTY READ -> leggere riga non ancora committata
- RIGHE FANTASMA -> righe delle quali vengo a conoscenza solo quando non faccio una nuova transazione

		t1    t2
		--
		---	
		--
	/*	--  >  10
		--
		--             */ righe fantasma
		--   > 20

- LETTURA NON RIPETIBILE -> una lettura che non si ripete nell arco del tempo
--------------------------------------------------------------
ACID
- dati atomici
- cooerenza (no dati sporchi)
- isolamento
- durata

--------------------------------------------------------------------------------
----------------PROCEDURE------------------------------------------------------------------------
create or replace procedure nome_p(p int, n varchar2) as
dichiarare variabili con relativi tipi


PARAMETRI(PROCEDURE E FUNZIONI)
3 tipologie di parametri
- IN [defaul]
- OUT [il parametro verra passato null e modificato nel corpo, 
	cosi modifico una var passata esternamente]
- IN OUT [parametro passato inizializzato e modificato nel corpo, 
	con indirizzo memoria passato esternamente]

Come?
nomeP(p_nome OUT tipo, p_cognome IN OUT congome)

VALORI PASSATI
Java   -> PER COPIA/VALORE!!!
PL/SQL -> IN         -> RIFERIMENTO
	  OUT/IN OUT -> COPIA

----ESEMPIO----
CHIAMANTE:

declare
v_locale number(3) := 10;
begin
dbms_output.put_line('Prima della chiamata: '|| v_locale);
test(v_locale);
dbms_output.put_line('Dopo la chiamata: '|| v_locale);
end;
/

PROCEDURE

IN)
create or replace procedure test(p_parametro in number) as
v_locale number(3);
begin
dbms_output.put_line('Blocco Begin End');
if p_parametro is null then
dbms_output.put_line('Parametro nullo');
else
dbms_output.put_line('Parametro ingresso: ' || p_parametro);
end if;
v_locale := p_parametro;
dbms_output.put_line('Dopo l''assegnazione: '||v_locale);
if p_parametro is null then
dbms_output.put_line('Parametro nullo');
else
dbms_output.put_line('Parametro ingresso: ' || p_parametro);
end if;
end;
/
RISULTATO IN
Prima della chiamata: 10
Blocco Begin End
Parametro ingresso: 10
Dopo l'assegnazione: 10
Parametro ingresso: 10
Dopo la chiamata: 10

-----
OUT)
create or replace procedure test(p_parametro out number) as
v_locale number(3);
begin
dbms_output.put_line('Blocco Begin End');
if p_parametro is null then
dbms_output.put_line('Parametro nullo');
else
dbms_output.put_line('Parametro ingresso: ' || p_parametro);
end if;
p_parametro := 20;
v_locale := p_parametro;
dbms_output.put_line('Dopo l''assegnazione: '||v_locale);
if p_parametro is null then
dbms_output.put_line('Parametro nullo');
else
dbms_output.put_line('Parametro ingresso: ' || p_parametro);
end if;
end;
/

RISULTATO OUT:
Prima della chiamata: 10
Blocco Begin End
Parametro nullo
Dopo l'assegnazione: 20
Parametro ingresso: 20
Dopo la chiamata: 20

-------
IN OUT)
procedure test(p_parametro in out number) as
v_locale number(3);
begin
dbms_output.put_line('Blocco Begin End');
if p_parametro is null then
dbms_output.put_line('Parametro nullo');
else
dbms_output.put_line('Parametro ingresso: ' || p_parametro);
end if;
p_parametro := 20;
v_locale := p_parametro;
dbms_output.put_line('Dopo l''assegnazione: '||v_locale);
if p_parametro is null then
dbms_output.put_line('Parametro nullo');
else
dbms_output.put_line('Parametro ingresso: ' || p_parametro);
end if;
end;
/

RISULTATO IN OUT
Prima della chiamata: 10
Blocco Begin End
Parametro ingresso: 10
Dopo l'assegnazione: 20
Parametro ingresso: 20
Dopo la chiamata: 20

----------------------------------------------------------------------------------
[PRAGMA] -> aggiungono funzionalita al paradigma

v_eeccexione exception
begin
si possono iterare cicli, creare transazioni
(finche comanti TCL o DML posso metterli in procedure, se invece DCL o DDL
serve NDS, un blocco che tramite una gestione automa 
risole il problema dei autocommit)

PROBLEMA -> SE UN UPDATE VA IN ERRORE SALTANO TUTTI E 5
begin
	update x5..
exception
	when tipo_exc then
	...
	when tipo_exc2 then
	...
	when others then
	...... [se nessuna precedenti allora cattura]

end;

SOLUZIONE -> si lavora su transazioni separate
begin
	begin 
		update..
	exception
		when no_data_found then
	end;
	begin 
		update..
	exception
		when no_data_found then
	end;
	ecc..
if(cond) then
raise(throw) v_eccezione;

exception
	when tipo_exc then
	...
	when v_eccezione then
	...
	when others then
	...... [se nessuna precedenti allora cattura]

end;
-------------------------------------------------------------
------------------------------------------------------------------
CURSORE
puntatore alla memoria(PGA), che serve per allocare i dati da modificare
[una sorta di memoria heap di java]

-------------------------------------------------------------------------
IMPLICITO[into]
si puo utilizzare quando la query di modifica restituisce una sola riga di risultati
(select stipendio from id_imp -> 1 valore)

CODICE
procedure modifica_stipendio(p_id int, p_modifica number) as
v_stipendio dipendente.stipendio%type;
exc_null exception;
begin
select stipendio into v_stipendio from dipendente
where id_dip = p_id;
if v_stipendio is null then
raise exc_null;
else
update dipendente set stipendio = v_stipendio + p_modifica
where id_dip = p_id;
end if;
exception
when no_data_found then
raise_application_error(-20100,'id dipendente non trovato');
when exc_null then
raise_application_error(-20101,'Stipendio da aggiornare nullo');
when others then
raise_application_error(-20102, sqlerrm);
end;

----------------------------------------------------------------------
ESPLICITO
Operazioni : Dichiararlo, allocare(caricare i valori), una volta aperto fetch, chiusura
quandpo la select dei risultat che vogliamo modificare ritorna piu di una riga
- se cursore deve solo leggere va bebe solo impostare la select 
- se no
	select stipendio from dipendente
	where livello = p_livello
	for update;
	
- con select con piu campi
	select stipendio from dipendente
	where livello = p_livello
	for update of stipendio;

CODICE:r
	
create or replace procedure modifica_stipendio2(p_livello int, p_modifica number) as
v_stipendio dipendente.stipendio%type;
cursor dip_cur is
	select stipendio from dipendente
	where livello = p_livello
for update;
exc_null exception;
begin
open dip_cur;
loop
	fetch dip_cur into v_stipendio;
	exit when dip_cur%notfound
	update dipendente set stipendio = v_stipendio + p_modifica
	where current of dip_cur;
end loop;
close dip_cur;
exception
when others then
raise_application_error(-20102, sqlerrm);
end;
------------------------------------------


-----------------------------------
il package in oracle è un file che contiene un elenco di funzioni


BLOCCO ANONIMO
utilizzo declare per dichiarare variabili


rowtype -> si seleziona tutta la riga

select * from dipendente
set serveroutput on
declare
v_dipendenti dipendente%rowtype;
cursor dip_cur is
select * from dipendente;
begin
open dip_cur;
loop
fetch dip_cur into v_dipendenti;
exit when dip_cur%notfound;
dbms_output.put_line(v_dipendenti.nome_dip||': '||v_dipendenti.stipedio);
end loop;
close dip_cur;
end;
-----------------------------------------------------------------------------------

CON WHILE
declare
v_dipendenti dipendente%rowtype;
cursor dip_cur is
select * from dipendente;
begin
open dip_cur;
fetch dip_cur into v_dipendenti;
while dip_cur%found
loop
dbms_output.put_line(v_dipendenti.nome_dip||': '||v_dipendenti.stipendio);
fetch dip_cur into v_dipendenti;
end loop;
close dip_cur;
end;

--------------------------------------------------------------------------------
FOR[utile per leggere]
declare
cursor dip_cur is
select * from dipendente;
begin
for v_dipendente in dip_cur    //apre automaticamente il cursore
loop
dbms_output.put_line(v_dipendente.nome_dip||': '||v_dipendente.stipendio);
fetch dip_cur into v_dipendenti;
end loop;
end;
---------------------------------------------------------------
SYSREFCURSOR -> fa riferimento a tutta la tabella, ho un riferimento di tipo cursore
--------------------------------------------------------------------------------------
CURSORI ANNIDATI
create or replace procedure ottieni_info(p_isbn char) as
cursor libro_cur is
select l.titolo, cursor(
select * from autore a
where
a.id = l.autore1
or
a.id = l.autore2
or
a.id = l.autore3)
from libro l
where isbn = p_isbn;
cur_autori sys_refcursor;
v_titolo libro.titolo%type;
v_autori autore%rowtype;
begin
open libro_cur;
loop
	fetch libro_cur into v_titolo, cur_autori;
	exit when libro_cur%notfound;
	dbms_output.put_line(v_titolo);
	loop
		fetch cur_autori into v_autori;
		exit when cur_autori%notfound;
		dbms_output.put_line(v_autori.nome||' ' ||v_autori.cognome);
	end loop;
end loop;
close libro_cur;
end;


---esercizo...
create or replace procedure inverti_nomi as
v_nome nominativi.nome%type;
v_cognome nomativi.cognome%type;
cursor nomina_cur is
select nome, cognome from nominativi
for update;
begin
open nomina_cur;
loop
	fetch nomina_cur into v_cognome, v_nome;
	exit when nomina_cur%notfound
	update nominativi set nome = v_nome,
	update nominativi set cognome = v_cognome,
	where current of nomina_cur;
end loop;
close nomina_cur;
exception
when others then
raise_application_error(-20102, sqlerrm);
end;

	
--------------------------------------------------------
NDS
execute immediate -> permette l esecuzioni di comandi ddl/dcl da procedure
(crea un involucro che chiude la transazione della procedura e ne fa una apposta (autonoma) per comando ddl/dcl

ESEMPIO
declare
v_statement varchar2(100);
cursor selezione_cur is
select trigger_name from
user_triggers;
begin
for t in selezione_cur
loop
	v_statement := 'Alter trigger '||t.trigger_name||' disable';
	execute immediate v_statement;
end loop;
end;

----------------------------------------------------------------
PRAGMA -> TRANSAZIONI AUTONOME

1) T- AUTONOMA
	create or replace procedure salva_dati(p_username varchar2, p_data timestamp) as
	pragma autonomous_transaction;
 	begin
		insert into dati values(p_username, p_data);
		commit;
	end;
2) T-CHIAMANTE
	create or replace procedure insert_autore(p_id int, p_nome varchar2, p_cognome varchar2) as
		begin
		insert into autore values(p_id,p_nome,p_cognome);
		salva_dati(user, systimestamp);
		rollback;
	end;
3) ESECUZIONE T-CHIAMANTE
	execute insert_autore(3,'turbo','mimmo');
4)
-------------------------------------------
PROCEDURE VS FUNZIONI
A)La funzione deve avere un tipo di ritorno

	1- create or replace funcion nomef(....) retun tipo as
		.....
	   return valore;
	2- create or replace procedure nomep(...) as
		...
B)modi differenti di chiamare 
	1- select nomef(..)
	2- execute nomep
C)funzione non utilizzata per fare aggiornamenti su tabelle
--------------------------------------------------
GOTO
<<nome_etichetta>>

goto nome_etichetta;
-------------------------------------------------------------------------------------------
TEST:
SQL> variabile stipendio number
SQL> exec :stipendio := calcolo(1)
SQL> print stipendio


-----------------------------------------------------------------------------------------------------
TRIGGER
select text from user_source where name = 'TEST'
ROUTINE AVVIATA DA UN AVENTO

EVENTO ->
	DML             SISTEMA

DEFINIZIONE TRIGGER
create or replace trigger nomeT
before -> eseguito prima di comando dml
 after ->          dopo
insted of -> sostituisce il comando dml

insert or update or delede in tabella/view

QUANTE VOLTE
[statement] -> corpo trigger eseguito una volta
for each row -> corpo trigger eseguito n volte - per ogni riga modificata dal comando dml
[when (cond)] -> restrizione di attivazione

OPERATORI DI CORRELAZIONE
(fuori dal blocco trigger sono accessibili senza ":")
		:new	:old
insert		  v	  -
update		  v	  v
delete		  - 	  v

PREDICATI DI TRIGGER
servono per controllare l evento attivante 

- if inserting then ...
- if updating then ...
- if deleding then ...

DICHIARAZIONE:
declare
.............
..........
begin
.........

exception

end;

--------ESEMPI---------------
1)
create or replace trigger genera_stat
after insert or update or delete on dipendente
declare
cursor dip_cur is
select livello,
sum(stipendio) somma_stip,
avg(stipendio) media_stip,
count(stipendio) conteggio_stip,
from dipendente
group by livello;
begin
delede from statistica_stip;
for v_stat in dip_cur
loop
	insert into statistica_stip values(v_stat.livello,
	v_stat.somma_stip, v_stat.media_stip, v_stat.conteggio_stip);
end loop;
end;
/


2)
create or replace trigger controllo
before insert or update or delete on dipendente
begin
if to_char(sysdate, 'DY') in ('SAB','DOM') then
raise_application_error(-20100, 'Non è possibile inserire i dati nel weekend');
end if;
end;

3)
create or replace trigger log_dipendenti
after insert or update or delete on dipendente
for each row
begin
if inserting then
insert into nuovi_dip values(:new.nome_dip,:new.stipendio,
user, sysdate);
elsif updating then
insert into aggiornamento_stip values(:new.nome_dip,:old.stipendio,:new.stipendio,
user, sysdate);
else
insert into licenziati values(:old.nome_dip, user, sysdate);
end if;
exception
when others then
raise_application_error(-20111, sqlerrm);
end;



4)
create or replace trigger aggiornamenti
after update on dipendente
for each row
when (new.stipendio <> old.stipendio)
begin
	insert into aggiornamento_stip values(:new.nome_dip,:old.stipendio,
	:new.stipendio, user, sysdate);
end;

------------------------------------------------------------------------------
TRIGGER DI SISTEMA

DEFINIZIONE
create or replace trigger nomeT
before | after	evento_sistema on turbo.schema|database
[when (cond)]
declare
..................
begin


end;

COMANDI DI SISTEMA			before		after			
- tutti ddl (create,alter,rename,	  x		  x
	drop,comment,truncate)
- logon
- logoff
- startup						  x
- shutdown				  x
- eventi dcl (grant, revoke)		  x		  x
- suspend						  x
- servererror						  x

LINK DI VARIABILI REPERIBILI DA SISTEMA -> 
https://docs.oracle.com/cd/B10501_01/appdev.920/a96590/adg14evt.htm

-------ESEMPIO-----------------------------------------
create or replace trigger controllo_ddl
after create on database
begin
insert into log_ddl values(user,ORA_DICT_OBJ_NAME,
ORA_DICT_OBJ_TYPE, ORA_DICT_OBJ_OWNER, systimestamp);
end;


-----------ESEMPIO TRIGGER INSERIMENTO-----------------
RENDE VISTE AGGIORNABILI
VISTA
create or replace view libri_view
as select l.isbn, a.nome, a.cognome, l.titolo
from libro l, autore a
where l.autore1 = a.id
or
l.autore2 = a.id
or
l.autore3 = a.id;

TRIGGER
create or replace trigger insert_view
instead of insert on libri_view
declare
v_libro libro%rowtype;
v_id_autore autore.id%type;
begin
	begin
	select id into v_id_autore
	from autore
	where nome = :new.nome
	and
	cognome = :new.cognome;
	exception
	when no_data_found then
	insert into autore values(autore_seq.nextval, :new.nome, :new.cognome)
	returning id into v_id_autore;
	end;
select * into v_libro from libro
where isbn = :new.isbn;
if v_libro.autore2 is null then
update libro set autore2 = v_id_autore
where isbn = :new.isbn;
else
update libro set autore3 = v_id_autore
where isbn = :new.isbn;
end if;
end;
/
CON SEQUENCE:
create sequence autore_seq start with 10

PACKAGE 
costruisto si
1) INTESTAZIONE -> create or replace package nomeP as
2) CORPO -> create or replace package body

Oggetto globale per catalogare le procedure e visto la visibilita database 
contiene delle procedure utilizzabili da tutti
---------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
SETTIMANA 3
LUNEDI
JDBC -> JAVA DATABASE CONNECTIVITI
Una pratica da seguire per potersi connnettere al DB
STRATO DI ASTRAZIONE SOFTWARE

DB CONNESSO TRAMITE TCP/IP

1) CAPIRE SE DB è ONLINE -> FASE PING
	Es: - turbo@orcl
	    - tnsping ORCL -> (necessaria risposta OK)	


select instance_name from v$instance; -> ritorna il nome vero del db dove stiamo lavorando (orcl)

nella creazione
NomeDB					AliasDB
orcl					orcl
accenture.com.analisi.vendite		vendite

alias utilizzabile solo per connessioni interne (no in JDBC)
SERVONO NUMERO PORTA(predefinito Oracle 1521) e indirizzo 
informazioni che si trovano tramite 1)lsnrctl 2)status
(se sono su server in cartella installazione oracledb/network/admin/listener.ora posso modificare anche
la configurazione del listener)

2)CARICARE driver di connessione JAVA,utilizzare la refelction
 	ORACLE -> jdbc/lib/ojdbc8
	da spostare in c

due tipologie :    thin 		oci
-thin [la macchina non ha db/oracle, piu lento]
-oci si basa su qualcosa precompilato [necessario client oracle o server]
[DRIVER permette all applicativo (java) di connettersi al db]

package java.sql.*;

3)Connection -si ottiene tramite> DriverManager.getConnection(URL di connessione, username,psw) 
!!URL DI CONNESSIONE DB = numero porta + indirizzo server + nome reale del SID
-------------CONNESSO---------------------------
4)Statement 	posso fare operazioni come DQL/DML/DDL/TCL/DCL
	con DQL -ritorna> 
  ResultSet(simile a cursore in PL che contiene le tuple selezionati)
		RICORDARSI DI FARE NEXT(sia con e senza ciclo)
  ResultSetMetaData(oggetto che legge metadati su resultset - quante colonne, nome dei campi,tipi dei campi)
5)CHIUDERE CONNESSIONE -> conn.close();
	[GarbageCollector controlla in automatico la conn JDBC]


----------------------DB CON ECLIPSE--------------
PROBLEMI
-se facciamo insert da eclipse riavviamo subito eclipse
-le sequenze non le visualizza
-se non fa refresh -> chiudiamo la connessione e riapriamo
-chiudere sqlplus mentre si lavora con eclipse
----------------------STATEMENT-----------------------
ResultSet ---- oggetto che viene ritornato in caso di una select 
[se apro piu resultset in una connessione devo chiudere quelli gia attivi]
	Concorrenza
	     - CONCUR_READ_ONLY [default]
	     - CONCUR_UPDATABLE
	Cursore
	     - TYPE_FOWARD_ONLY [default] [no salti tra record]
	     - TYPE_SCOLL_SENSITIVE 
	     - TYPE_SCOLL_INSENSITIVE
				 
SENSITIVE VS INSENSITIVE
 App		Database
T1		T2
		1
		2
lettura		3	[INSENSIBLE -> quando chiuso la connessioe -> ritorna i primi 3(i valori quando il result set è stato aperto) ]	
		4
		5
			[SENSIBILE] -> le moifiche riperquoto anche sul resultset

conteggiare i record:
rs.last()
rs.getRow() -> il numero del record sulla quale ci troviamo

IMPOSTARE STATEMENT
Statement stmt = conn.createStatement(ResultSet.TYPE_SCOLL_SENSITIVE, 
\				      ResultSet.CONCUR_UPDATABLE);

METODI SALTARE TRA UN RECORD ALL ALTRO
boolean next() -> uno per volta
boolean previous() - scroll
boolean absolute(int i) - scroll
boolean first() - scroll
boolean last() - scoll
void beforeFirst() 
void afterLast() - scroll
int getRow() - riga su cui ci troviamo
-------------------------------------------------------------------------
OPERARIONI RESULT SET

1)insert
	ResultSet rs = stmt.executeQuery(SELECT_UTENTE[campi che voglio riempire]); 
!!!!!!!nella selezione per un inserimnto non si deve mettere l * ->specificare i campi che voglio inserire !!!!!!!!!
	rs.moveToInsertRow();
	rs.updateLong(1,Utente.getId());
	rs.updateString(2,Utente.getNome());
	rs.updateDouble(3,Utente.getStipendio());
	rs.insertRow(); -> se jdbc auto-com -> commit;
			-> se jdbc !auto-com -> aggiorna il resultSet
				conn.commit();


2)update
	ResultSet rs = stmt.executeQuery(SELECT_UTENTE[campi che voglio aggiornare]); 
	(se select return una sola riga allora no ciclo, altrimenti obbligatorio)
	[ciclo]
	rs.updateLong(1,Utente.getId());
	rs.updateString(2,Utente.getNome());
	rs.updateDouble(3,Utente.getStipendio());
	rs.UpdateRow(); -> se jdbc auto-com -> commit;
			-> se jdbc !auto-com -> aggiorna il resultSet
				conn.commit();



3)delete

	ResultSet rs = stmt.executeQuery(SELECT_UTENTE[campi che voglio aggiornare]); 
	(se select return una sola riga allora no ciclo, altrimenti obbligatorio)

	rs.deleteRow(); -> se jdbc auto-com -> commit;
			-> se jdbc !auto-com -> aggiorna il resultSet
				conn.commit();

4)select

-------RESULTSETMETADATA---------------------------------------------------------
int getColumnCount()
String getColumnName(int column)
String getColumnLabel(int column) -> legge alias
Object getColumnClassName(int column) -> tipologia Java del campo contenuto della colonna
int getColumnType(int column) -> tipologia sql
	[java.sql.Types -> contiene le costanti associate alle tipologie sql]
String getTableName(int campo) -> ritorna la tabella dove ce quel campo

Statement
PraparedStatement -> serve per istruzioni sql parametriche (EVITARE SQL INJECTION)
!!NON FARE!!! -> SQLINJECTION
String nome = "Select nome,cognome from tab where campo = "+ var; 
il parametro deve essere compilato su db

---------------------------------------------------------
FILE CON PROPRIETA DI CONNESSIONE
Utile perche non viene compilato ogni volta, e basta nasconderlo in modo criptato

----------RowSet---------
le connessioni non sono sincronizzate
dunque rowset serve a dare un ordine per i thread(client)
due versioni
1)JdbcRowSetImpl -> 		
2)CachedRowSetImpl:(gestice anche modifiche corpose)
	i dati da modificare li tiene in cache per poi sconnettersi dal db
	posso modificare i dati online, sincronizzato
	finito tutto -> row.acceptChanges(); = connect + commit;
	svantaggio -> si apre e chiude tante volte il db

METODI
rowSet.setType(ResultSet.COSTANTE)
rowSet.setConcurrency(ResultSet.COSTANTE) -> Suoi dati in cache

NB:finche non ho finito l elaborazine dei dati devo stare online

-----------CollableStatement------------
permette di eseguire chiamate a procedure
-> sql : {call nomeP(..)}

-----------JPA: Java Persinstance Api------------
Insieme di classi metodi, sono strumenti ORM(OBJECT RELATIONAL MAPPING) che aiutano 
grandi quantà di dati su db


ORM -> Il model viene utilizzato come mappatura nel db
STRUMENTO ORM -> supporto di persistenza, che automazza, e ha capacità di convertire da tipo oggetto
		a tipo relazionale, e contrario.
MODEL -> Classe di getter e setter (per orm serve costruttore vuoto) 
	 (Chiamato anche: Entity in JPA,Hybernate, Bean in Enterprise,VO, POJO)

EntityManagerFactory -> crea istanze EntityManager
EntityManager -> interfaccia operazioni di persistenza su obj, lavora come factory per gestire istanze Query
Query -> Interfaccia: crea oggetti relazionali che conicide con il criterio di selezione impostato
Entity -> Equivalente dei singoli record inseriti nel db
EntityTransaction -> Rappresenta transazione: gestisce anche le relazioni tra tabelle(se modifco le classi,
			 automaticamente anche la tabelle si modificano)

DDL-GENERATION(in file xml proj JPA)
-> create-tables
-> create-or-extend-tables
-> drop-and-create-tables

---------------------------------------------------------------------------------
JPQL(Java Persistance Query Language)
Simile a SQL solo che interroga gli oggetti, il from è riferito agli oggetti non tabelle

VANTAGGIO ORM
no statement, no resultset, no connessioni a db

Relazioni ORM
-> Many-to-one 
-> One-to-Many
-> Many-to-Many

-----------Ereditarieta Java/SQL-----------------
@Inheritance
definiamo noi dove inizia la catena di ereditarieta che vogliamo nel db




MODULO RICERCA
1-IL PRODOTTO CHE HA VENDUTO DI PIU
2-I PRODOTTI PIU COSTOSI
3-IL VENDITORE DATI
4-DATI TOTALE -> TABELLA DB


---------------------------------------------------------------------------------
TOMCAT
Necessarie variabili d'ambiente
-> JAVA_HOME
-> CATALINA_HOME

CHE COS'E
Web Container -> applicativo che gira su un server, lo scopo è da fare un involucro per i client,
fornire l infrastruttura per comunicare con i client

DIFFERENZE APP-SERVER/WEB CONTAINER:
APPLICATION SERVER: Meccanismi di pooling(gestisce carichi di lavoro)/ 
		supporto a tutte le tecnologie(sono anche web container ma non viceversa)
WEB CONTAINER: Versione semplicata/legera di un App.Server - fornisce elementi base per un app web completa

DIFEFRENZE SERVER/APP-SERVER
Server - macchina fisica che contiene l infrastruttura tecnica sia hardware ce sorfware capacr di comunicare con i client
Application server/web container -> Applicativi che servono per compilare in maniera dinamica le applicazioni

Mondo Web
-> applicazone statica (HTML)
-> applicazione dimanica (JAVA) -> compilata e mandata in esecuzione da un web container 
-> PHP -> non ideale per app complesse
-> Mondo Microsoft

DIRECTORY TOMCAT
-bin strumenti funzionamento
-webapp contiene le app gia deployate
-conf file xml configurazione(importante server xml)
-work ci sono i sorgenti dei file compilati delle pagine web dinamiche(come html)

MANAGER APP(LOCALHOST:8080)
-ID di sessione (associato al browser con la quale navighiamo)
-Expire session (dopo tot tempo mi scade l id di sessione)
-Reload (Evita di riavviare il server): 
	1)solo se si modificano le classi di java
	2)solo se si modifica xml di config
-WAR file (Web archive) equilvalente del file jar per le app web(contiente tutti file di progetto) 

SESSIONI
Quando termina
1)Scade la sessione
2)Logout
3)Chiudere tutte le istanze del servizio dal browser







SCALARE -> parto con un server solo e arrivo ad es 5, dunque serve un bilanciatore di carico


-----------------JAVA ENTERPRISE---------------------------------------------
Utile per creare app distribuite(concetto client-server)
Tutto gia implementato in modo thread safe
Sono tutte scalabili


1)Servlet 
Componente Enterprise (Interfaccia)

Che cos'e -> Classe che implementa Servelet e estende una classe(HttpServlet): componente che risiede sul server
	HttpServlet: specializzata nella gestione del protocollo HTTP

SCOPO-> intercettare le richieste che arrivano da parte dei client - cattura eventi(Controller)
(NB necessario che il componente sia compilato da un webcontainer o appserver(Jboss/Servelet))

DOVE SI PONE: tra la BusinnesLogic e il DataLayer (PresentationLayer dove View e Controller)
	Pagine HTML/JSP -> Servelet -> | Facade ->BusinnesLogic -> | DAO -> Database

Esiste anche GenericServelet non si utilizza quasi mai

------------Ha un suo ciclo di vita---------------------------
1) void init() -> inizializzare la servlet quando arriva la richiesta
	richiamato una solva volta alla prima richiesta

  -ServeletConfig getServeletConfig() -> serve per leggere gli eventuali parametri di configurazione
  	scritti all interno di un file chiamato: web.xml (descrittore di deploy: caratteristiche generali di progetto)
	puo essere passato a init(ServeletConfig config) -> se cosi allora prima si chiama config e poi fa l init	

  -String getServeletInfo() -> dentro web.xml si possono mettere info sul componente creato

2) void service(ServeletRequest request, ServeletResponse response)
	tramite questo metodo la servelet gestisce tutto
	chiamato una volta per ogni richiesta

3) void destroy() -> deiniazializzata Servelet
	è l appserver o webcontainer che richiama il destroy (se reload o shutdown)

NB :Perche lato web java alte prestazioni:
perche il componente che riceve le richieste viene inizializzato
 una volta sola durante i ciclo di vita del progetto


-----------HttpServlet---------------------------------------------------------------------

- void init()
- String getServeletInfo()

- void doGet(HttpServeletRequest request, HttpServeletResponse response)
- void doPost(HttpServeletRequest request, HttpServeletResponse response)
	NB:implementazione del metodo service() della Servelet generica

void destroy()

POST -> Invia dei dati al server tramite(per forza)l' header(http) 
	i dati vengono nascosti(moduli registrazione, login) QueryString nascosta
GET  -> Puo ottenere i parametri della richiesta direttamente nell url allora QueryString = (? + robe)
		in chiaro
PUT
DELETE
se passo richiesta get a post -> Error 405

ServeletException
	tiene traccia di tutte le eccezzione
IOException 
	quando si invia la risposta il formato del file potrà essere
	MIME-MultipurposeMailExtenxion
		-> html
		-> txt
		-> xml
		-> json
	
tipo di codifica per pagine
- default ISO8859-1

Per inviare le risposte si utilizza un Buffer di risposta
con dimensione di default di 8kb (in caso di overflow si incrementa il valore del buffer)

----------------------------------------------
webapp -> le cartelle sono: radice del contesto del progetto
all interno della cartella ma fuori da WEB-INF è tutto webcontent
Se metto pagina html chiamata index -> sara la pagina di avvio

---------------HTML------------------------------------------------
no case sensitive
<!doctype html> -> HTML5

<html>

<head> si inseriscono metatag (autore titolo)
<title>Primo esempio</title>
</head> 


<body> -> tutto quello che si visualizza nella pagina
<h3>   -> TAG SEMANTICO (h vanno da 1 a 6, 1 il piu grande e più importante)

<section> -> SEMANTICO
<div> ->NON SEMANTICO [Divisore]
<p>   ->NON SEMANTICO [Paragrafo]


<form action="/esempio/urlRichiesta" method="get"> action=""[chi deve ricevere le informazioni]
root/url 
tr table row
td cella della tabella
placeholder="Inserire il cognome.." :testo che sparisce
</body>
</html>
--------------------DIFFERENZA TAG 1-----------------------------------------------------------------
TAG SEMANTICI
Da il valore semantico al titolo, quindi il browser quando lo legge riconosce che è un titolo
Lo spider lo vede
Piu tag semantici ho, più ho possibilita di indicizzare la pagina

TAG NON SEMANTICI
Non da nessuna informazione sul titolo

Contano di più il contenuto che non le keywords che si mettono in alto
---------------DIFFERANZA TAG 2----------------------------------------------------------------------
TAG A BLOCCO
Tag che una volta che li definisco vanno automaticamente a caso
  -> <p> 
  -> <div>

TAG IN LINEA
Si allineano uno di fianco all altro
	-> href
	-> a
In CSS si usano i float per sistemare i tag
-------------------------------------------------------------------------------------
- <a> ADDRES
-href link


------------ECLIPSE WEB-----------------------------------------------------------------
con i welcome file possiamo decidere quali sono le pagine di avvio per ogni tipologia di utente

Posso usare annotation per mappare le servlet al posto 


Filer : Servlet + despacth componente (rimanda i parametri in ingresso ad un altro componente)
Listener : Attende eventi sul web

---------DESCRITTORE DI DEPLOY---WEB.XML-------------------------------------------
1) Descrizione applicazione : tutte le meta informazioni
2) Parametri inizializzazione
3) Mappatura Servlet - Filter - Listener
4) Timeout di sessione
5) Welcome File
6) Mappatura Errori: quando si verifica errore 404.. o eccezioni richiama una pagina predefinita
7) Icone sul sito
8) Regole di sicurezza: quali sono utenti possono accedere a parti riservate

!!!I NOMI DEI FILE SONO CASESENSITIVE!!!
TAG 
<display-name> MimmoProject </display-name>
<description> tutto quello che voglio </description>

<session-config>
	<session-timeout> 20 </session-timeout>
</session-config>

<welcome-file-list>
	<welcome-file>index.html</welcome-file>
	<welcome-file>index.jsp</welcome-file> -> cosi la prima che trova carica
</welcome-file-list>

<error-page>
	<error-code>404</error-code>
	<location>/error404.html</location>
</error-page>

Posso mettere anche le eccezioni
<error-page>                      (Throwable: prende anche robe come cicli infiniti
	<exception-type>java.lang.Exception</exception-type>
	<location>/exception.html</location>
</error-page>

GETSIONE DELLE RISPOSTE
<mime-mapping>
	<extension>html</extension>
	<mime-type>text/html</mime-type>
</mime-mapping>

ICONE
<icon>
<small-icon>/path-immagine.gif o .png</small-icon> 
<large-icon>/path-immagine.gif o .png</large-icon>
</icon>

 <servlet>
	<description>Servlet</description>
	<load-on-startup>1</load-on-startup> ->ordine con la quali eseguire le servlet
	<servlet-name>prima</servlet-name>
	<display-name> MimmoProject </display-name>
	<servlet-class>it.betacom.controller.PrimaServlet</servlet-class>
	<init-param>//parametri da leggere come parametri in init()
		<param-name>test</param-name>
		<param-value>testodiprova</param-value>
	</init-param>
</servlet>

<servlet-mapping>
	<servlet-name>prima</servlet-name>
	<url-pattern>/urlRichiesta/* </url-pattern>
</servlet-mapping>
NB: con l * tutto quello che cè dopo url richiama questa servlet


PAGINE JSP 
Equivalente delle servlet ma scritte in HTML (con estension .jsp)
<servlet>
	<description>Servlet</description>
	<load-on-startup>1</load-on-startup> ->ordine con la quali eseguire le servlet
	<servlet-name>prima</servlet-name>
	<display-name> MimmoProject </display-name>
	<jsp-file>/controllo.jsp</jsp-file>
</servlet>
<servlet-mapping>
	<servlet-name>prima</servlet-name>
	<url-pattern>/controllo.jsp</url-pattern>
</servlet-mapping>

FILTRER -> (Servlet + Dispatch dei dati)
<filter>
	<description>Servlet</description>
	<load-on-startup>1</load-on-startup> ->ordine con la quali eseguire le servlet
	<filter-name>prima</filter-name>
	<display-name> MimmoProject </display-name>
	<servlet-class>it.betacom.controller.FilterClass</servlet-class>
</filter>
<filter-mapping>
	<servlet-name>prima</filter-name>
	<url-pattern>url</url-pattern>
</filter-mapping>

LISTENER VS SERVLET 
Listener in attesa di eventi(shudown, pause...)
Servlet viene richiamata in maniera esplicita

<listener>
	<listener-class>it.betacom.listener.ListenerClass</listener-class>
</listener>

PARAMETRI INIZIALIZZAZIONE
Parametri associati ad uno solo componente(Servlet/Filter)

PARAMETRI DI CONTESTO
da tutti i componenti(CONTROLLER) del progetto posso accedere a questi parametri
(possiamo mettere ad esempio dati connesione db)
<context-param>
	<param-name>contextparam</param-name>
	<param-value>paramcontesto</param-value>
</context-param>


--------------------------------------------------------------------------------------

JNDI
Tecnica per leggere i parametri di configurazione direttamente dall application server
Danno nomi univoci in modo da non fare piu riferimento alle locazioni dei driver

<resource-ref>
	<description>JDBC Connection Pool><description>
	<resource-ref-name>jdbc/oracle</resource-ref-name>
	<resource-ref-type>javax.sql.Datasource</resource-ref-type>
</resource-ref>

----------DATASOURCE IN JAVA---------------------------------------------
javax.sql.Datasource -> simile alla connection dei jdbc ma va gestita dall appserver

Context contesto = new InitialContext();
Context webContext = (Context)contesto.lookup("java:env/var"); -> riceve quello che è stato
DataSource ds = (DataSource)webContext.lookup("jdbc/oracle");
Connection conn = ds.getConnection();


-------HTML-
<a> ADDRES
	href link




--ESERCIZIO--
select max(sum(tot)) from (select sum(tot),v.id from venditore v,modulo m, venditore_modulo vm
where v.id = vm.venditore_id
and vm.moduli_cod_mod = m.cod_mod
group by v.id)

FOGLI DI STILE CSS
E' un linguaggio di formattazione che va a sostituire vecchi tag html
Può essere:
- esterno
- interno
- in linea

UN ALTRO DI QUESTO -> BOOTSTRAP
-continer ->griglia 12x12


!!!!CON OVERRIDE NON POSSO RILANCIARE ALTRE ECCEZIONI
-> quindi rilancio una nuova eccezione dal metodo

-----------FILTER----------------------------------------------------------
[Interface]: E' come una servlet(intercetta i dati di una richiesta) pero fa una dispatch
Utile per creare il concetto di controller
DIFFERNZA:
Il filtro intrcetta l evento della chiamata(tramite il mappig) non come la servlet che viene chiamata
SCOPO:
Si inserisce tra la chiamata e il componente businness
METODI:
- init(FilterConfig config)
- doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
	chain: effettua il reindirizzamento dei dati
- destroy()



--------------------------------------------------------------
JSP(Java Service Page)
Normale pagina HTML MA pagina dinamica(non come HTML) viene compilata lato server
(web container, app ser). Capacità di contenere codice Java all interno della pagina
!!!SCRIPLET:componente che ci permette di scrivere dinamicamente!!!
-> RISULTATO -> SERVLET
Non serve mapparli nel file web.xml

Stesso componente ma SCOPI diversi
JSP: Presentation Layer[sempre]
Servlet:PL/Businness component

<%@ -> DIRETTIVA: Dare direttive di compilazione(mex messaggi a web container o app server)
charset: inerente alla pagina
pageEncoding: come viene inviata la risposta
COMMENTI
<!-- commento HTML -->
<%-- commento JSP --%> (commento che non si vede sul client)
Negli scriplet
<%
	//commento java
%>

<meta http-equiv="refresh" content="60"> FORZARE UN REFRESH TEMPORIZZATO
<%= ESPRESSIONE
<%! DICHIARAZIONE

NB OGGETTI IMPLICITI: Non ce bisogno di definirli perche i web container riconoscono che tipo di oggetto sa
NB Le variabili dichiarati nello scriplet hanno visibilità nello scriplet, se le dichiaro ha visibilità di contesto
	(finche non distruggo l applicazione rimane inizializzata)

CICLO DI VITA[vale lo stesso per le servlet]:
- void jspInit()
- void _jspService(HttpServerRequest rq, HttpServerResponse rs)
	[no richiamato, no sovrascritto]
	Qui possono arrivare sia richieste get che post

	//se voglio tenere sotto controllo i metodi posso fare cosi
	<% if(request.getMethod().equals("GET")){
		response.sendRedirect("index.jsp")
	%>

- void jspDestroy()

@se voglio fare l override di jspinit e jspdestroy lo devo fare nella dichiarazione

---------------------------------------------
OGGETTI IMPLICITI
NB:nella dichiarazione non posso utilizzare oggetti impliciti a meno di pagecontext
Visibilità:
-application[per azzerare reload o azzerare]
-session
-page 
-view NO in jsp
-request [nasce e muore con la richiesta]

P1		P2
menu		menu
Oggetto -> 	NO
SI		refresh NO

OGGETTI IMPLICITI VISIBILITA PAGE 
-<% scriplet%>
-out 	   -> javax.servlet.jsp.JspWriter
-config    -> javax.servlet.ServeltConfig
-exception -> java.lang.Throwable
-page[equivalente di this]   -> java.lang.Object
-response  -> javax.servlet.http.HttpServletResponse
-pageContext -> javax.servlet.jsp.PageContext[scopo:definire tutti gli obj impliciti]
		(chiama in automatico il webCon per i riferimenti degli altri obj impliciti
		 gestisce anche il buffer di risposta)

In enterprise i model sono chiamati "Bean"

OGGETTO IMPLICITO VISIBILITA SESSION
-session -> javax.servlet.http.HttpSession


OGGETTO IMPLICITO VISIBILITA REQUEST
-request ->javax.servlet.http.HttpSession


OGGETTO IMPLICITO VISIBILITA APPLICATION
-application -> javax.servlet.ServletContext

OBJ IMPLICITO
exception: non puo essere usato nel body(per farlo devo definire la pagina jsp come pagina di erroe)


<%@page buffer="20000"%>
<%
	response.setBufferSize(200000);
%>

set contentType("plain/text");

FORM MULTISTEP
P1	P2	P3 -> registrazione
->	->	-> -> finake
i dati devono rimanere bufferizzati -> page autoFlush = "false" + response.flushBuffer()
<%@ page autoFlush = "true" (evita di mandare in overflow il buffer 
	ogni cambio di pagina si refresha il buffer)



-response.isCommitted() -> utile quando reindirizzamenti multipli ad una pagina
-response.sendRedirect()

Nella servlet c è getServletInfo()
dunque nella jsp posso fare 
<%@ page info="descrizione jsp"%>
<%
	((Servlet)page).getServletInfo();
%>

-----REQUEST---------
metodi
- String getParameter()
- getParameterValues() ->array
- getParameterNames() -> enumeration

	<form action="" method=
		<input type"text" name"anagrafiga"<Nome</br>
		<input type"text" name"anagrafiga"<Cogome</br>
		<input type"text" name"anagrafiga"<Indirizzo</br>
		altri 30
	-> serve getParamValues("anagrafica")

	<form action="" method=
		<input type"text" name"nome"<Nome</br>
		<input type"text" name"cognome"<Cogome</br>
		<input type"text" name"indirizzo"<Indirizzo</br>
		altri 30
	qui serve getParamNames()

- getContentLength
- getContentType()
- getMethod() (post,get)

-------APPLICATION---------
Definire elementi globali del progetto che rimangono tali per tutto il ciclo di vita del progetto

- application.setAttribute("test",cliente);
- Cliente c = application.getAttribute("test");
- application.removeAttribute
- getServerInfo()
-------SESSION-------------------------------------------------
NELLE JSP LA SESSIONE è GIA ATTIVA E LA POSSO DISATTIVARE
NELLA SEVRLET LA DEVO ATTIVARE
	- doPost()
		HttpSession session = request.getSession();
Operazioni
- setAttribute("username", utente.getUsername())

	if(session.getAttribute("username") == nll{
		response.sendRedirect("login.jsp");
	}
oppure
	carrello --> List<Prodotti>
	setAttribute("spesa", carrello)
	Carrello car = session.getAttribute("spesa");
	session.removeAttribute("spesa");
	session.invalidate();

COOKIE-> memorizzano su pc delle metainformazioni della navigazione
-------------------
cè costruttore del Date con millisec
new Date(session.getCreationTime())
GregoriaCalendar c = new GregorianCalendar();
c.setTime(



LISTENER
- SessionListener
- ContextListener


-------------------------------
UTILITA
Compattare:
[dir:WEB-INF]jar -cvf ../nomeapp.war *
se si lanciamo ci crea l archivio
Scompattare
jar -xvf nomeapp.war




-------------------------------------------
Servono per dare info aggiuntive alla pagina
DIRETTIVA
<%@ -> compilata in fase di traduzione e basta
	<%@ include file="head.html" %>
AZIONI
<jsp: -> valutata in maniera dinamica ad ogni richiesta
	<jsp:include page="head.html"></jsp:include>

->include : le parti di una pagina le gestisco in modo autonomo in modo che poi	
	nella pagina ci monto dentro i pezzettini

<jsp:foward
---------------------------

BEAN
Sono delle classi normalissime che servono come strumento di mappatura dei dati
hanno diversi nomi Bean/Entity/

<jsp:useBean id="cliente" class="it.betacom.businesscomponent.model.Cliente" 
scope="[stesse per gli ogetti impliciti]" type="it.betacom.businesscomponent.model.Persona"/>

-  <jsp:setProperty /> = cliente.setNome()
<jsp:setProperty name="cliente" property="nome" value="<%= request.getParameter()%>" />
<jsp:setProperty nome="cliente" property="*" /> -> popola il bean cliente automaitamente
NB:
	[attributi clinte devono corrispondere con i nomi della form]
	[non funziona con le date]


----------CLASSI Assembler---------------
Classi che tramite dei metodi set settano tutte le proprieta del bean


-  <jsp:getProperty name="cliente" property="nome" />
NB non solo recura i dati ma invia anche la risposta al client (out.println())

---------CONVERIRE DATA UTIL IN SQL
new java.sql.Date(cliente.getNascita().getTime());



----------------MAVEN---------------------------
Tools di automazione
download e settaggio automatico delle librerie

---------------HYBERNATE-----------------------
Semplifica la gestione con il db

SessionFactory
Fornisce un modulo sincronizzato 
Transaction
- Linguaggio HQL[Hybernate query language]

TIPI DI OPERAZIONI DDL
-drop-and-create
- create-drop
- none
- create
- update
- valide

--------HQL:Hibernate Query Language
Query query = session.createQuery(HQL);
List<?> risultati = query.list();

- String hql = "from Impiegato i"
- String hql = "select i.nome, i.cognome from Impiegato i where
	i.id = :id_imp"
   Query query = session.createQuery(HQL);
   query.setParameter("id_imp", 1);
   List<?> risultati = query.list();

- String hql = "insert into Fornitore(nome, cognome) select nome, cognome from Fornitore2";
   Query query = session.createQuery(HQL);
   int modifica = query.executeUpdate();

- String hql = "update Impiegato i set i.stipendio = :stipendio where i.id = :id_imp";
  Query query = session.createQuery(HQL);
  query.setParameter("stipendio", 10000);
  query.setParameter("id_imp", 1);
  int modifica = query.executeUpdate();

- String hql = "delete from Impiegato i where i.id = :id_imp";

-------------JUNIT-------------------------
I test in Java vengono scritti maggiornamente in Junit
Framework per testare
fail(mex) -> induce il test a fallire

-> Assert : Componente che serve per impostazioni durante il test
	Parametro 1 utile per la documentazione del testing

	- assertEquals		("test 1.1: Verifica ...", 10, metodo());
     	- assertFalse/AssertTrue(test
	- assertNull/NotNull   	(test .., obj/metodo)
	- assertSame		(test.. , metodo1, metodo2) -> ritorna true se simili

NB: SIMILI se appartengono alla stessa catena di ereditarieta

FASE DI INIZIALIAZZAZIONE TEST
Per fare diversi test simili tra di loro
posso sovrascirvere metodi di init per creare oggetti da testare

public class EsempioTest extneds TestCase()
private Cliente c;
  @Override
- setUp()
	c = new Cliente();
	c.nome = "Massimo";
	c.cognome = "Rossi";
	c.indirizzo = "Via Milano";

  @Override
- tearDown{
	c= null;	
}

publi void testCliente(){
	Assert.assertEquals("..", metodo(), c)
(chiama tear down)

publi void testCliente2(){
	c.indirizzo = "Via Padova, 4")
	Assert.assertEquals("..", metodo(), c)

SetUp e TearDown vengono chiamati sempre durante l esecuzione di un metodo test

-----JUNIT 4-------------
@Test(timeout = 3000) -> dopo 3 secondi il test fallisce

@BeforeClass -> all inizio di tutti i test(globale per tutti i test)
static metodo -> Esempio: conn DB

@Before
setUp

@Test1
@Test2
@Test3

@After
tearDown

@AfterClass
static metodo

-------JUPITER---------
@Ignore -> non esegue il test ma ci fa vedere che è da implementare
@Test
metodo

---------------JAVASCRIPT---------------------
Puo essere compilato lato client(browser) o server(strumenti node.js)
Lavora con elementi del dom(elementi di html) 
Lavora tanto con gli eventi della pagina

---------------------------------
I link esterni ad un progetto vanno inseriti in una section
- ul : unordered list

INCLUDE:
<jsp:include page="nav.jsp"/>
PER ANNOTAZIONE
<%@include file="CDN.html" %>
---------------CSS----------------
1) indicare quali tag da formattare
	posizione: Relativa (in modo relativo posso disporre nella pagina)
2) body 
	- indicare i margini

id: univico -> nel css per richiamare ci vuole #
class: ci possono eseere piu elementi

MEDIAQUERY -> quando la dimensione dello screen scende sotto un limite: possiamo impostare
condizioni differenti per la formattazione della pagina
@media screen and(max-width: 760px)


-----------REGEXP------------------
Tutte le possibili combinazinìoni
https://developer.mozilla.org/it/docs/Web/JavaScript/Guida/Espressioni_Regolari

esempi
- /^[agfz] $/ primo carattere deve essere uno diquelli
- /^[a-zA-Z ,.'-]{2,30} $/ validita per il nome
- (?=.*[a-z]) almeno una lettere minuscola
- (?=.*[a-z])(?=.*[A-Z])(?=.*[\d]) almeno una lettere minuscola, maiuscola, val nuemrico
- [\w] vale tutto

<img src="img/<%=a.getImg()%>" alt="Responsive image" class="img-thumbnail">

WEB SERVICES

- REST
	Usati maggiormente(oiù veloce) si appoggia al prtocollo http
	possono utilizzare diversi file di interscambio(XML,JSON,HTML)
	Librerie: -jaxrs
	USA WADL + XML/JSON + HTTP
- SOAP
	Basato su schemi XML- dunque utilizza un protollo interno (più sicuro)
	Puo scambiare dati solo in formato XML
	Librerie: -jaxws
	USA WSDL + MESSAGGI XML + QUALSIASI PROTOCOLLO

CORS(Cross origin resource sharing) 
mexccaniscmo che usa header del protocollo http,
aggiunge delle informazioni addizionali a http per le norme di accesso a server

JSF
framevork sulla parte JSP 
El -> expression language
si basa sulla jsp ma deve essere .xhtml
nate perche separano inn maniera netta il presentation layer dalla parte di businness logic


DIPENDENZA INJECTION
Capacita del contesto di generare in automatco le istanze del codice senza istanziarle
in maniera esplicita
import javax.inject.Named; -> @Named

XHTML -> si appoggiano a validazioni xml
HTML5 -> si appoggia a DTD w3 per descrivere i tag utilizzati in html

INIEZZIONE DI DIPENDENZA
Il riferimento delle classi con @Named le chiamo con la lettera minuscola
@Named
TemaUI
-> con temaUI faccio riferimento alla istanza del tema

se mettp getTema() -> si sottointende che ci sia un campo di istanza
#{temaUI.tema}

<p:inputText value="#{utente.nome}"  -> si attiva la inject

BINDING associazione diretta di un componente back end con una proprieta frontend

WEBSERVICE 
Sono componenti che espongono delle api(url da richiamare), 
vantaggio - li posso chiamarare da qualsiasi tipo di architettura


VERBI HTTP
-get (leggere)
-post (scrivere)
-put (aggiornamenti)
-delete (cancellare)

@Consumes() -> chi deve madare la richiesta
@Produces(MediaType.APPLICATION_JSON) -> cosa ritornA


<f:ajax execute=".." render=".."/> 
1 componente che elabora
2 componente destinazione
COMPONENTE PER CHIAMATE ASINCRONE -> HTTPXMLObject !!!!!!!!!!!!!!!!!!!!

PERCORSO:
1 - spolverata su OP (gestione file, serializzazione, XML)
2 - sql (plsql, routine, query, creazione tabelle)
3 - JDBC, ORM(JPA(java ee), Hibernate)
4 - Livello WEB: Servlet, listener, JSP, filter
5 - Utilizzati sempre i DP(factory, singleton, adapter)
6 - Sviluppato un app basata su tre strati(MONOLITICO) con db oracle, dao
	businness logic che gestiva, e presenation layer JSP(prettamente sincrono)
7 - JSF(differenza con JPA, asincrono utilizzando AJAX)
8 - HTML, CSS, BOOSTRAP
DOPO AVER VISTO -> FRAMEWORK
9- Spring - SpringBoot(microservizi) - Springcore
10 -Angular consumare i web service che esponevano i dati

CONTARIO APP MONOLITA
-> MICROSERVIZI: ogni pezzo dell applicazione puo essere fatto in un linguaggio diverso

TRANSAZIONE:
Sono i dati modificati attraverso un comando DML posizionati sul segmento di rollback,
e finche non eseguo un comando commit o rollback rimangono nella memoria PGA

INTEGRITA REFERENZIALE
eè un software che va a controllare che i dati siano coerenti con lo schema del db

----------------------------------SPRING----------------------------------------------
------------Spring Core----------------------
-Lazy inizializaton:
-Dipendencies Injection
-POJO; Model base
-IOC: Sara il contesto di esecuzione del framework a creare oggetti(POJO) per noi
-DI

------------Spring-Web-MVC--------------------
Si basa su delle servlet predefinite
Si scrivono meno righe rispetto alla cattura dei dati

------------Spring Security-------------------------
Gestione della sicurezza -> validazioni lato server, autorizzazioni, ecc..

-----------Spring Cloud-----------------------------
Gestisce servizi sul cloud come i server AWS sul cloud

-----------Spring Boot------------------------
Utile a creare applicativi complessi che espongono a api(microservizi)

------------Spring-JDBC------------------------

------------Spring-Data-----------------
Simulare in gestione diretta ORM classici, tramite supporto di persistena JPA



VISIBILITA' DEI BEAN SPRING
Singleton -> Una istanza all interno dell applicativo
Prototype -> Posso fare una copia dell elemento

Colloquio
DIPENDENCIES INJECTION(Per costruttore)
Nella classe auto ce motore che viene passato nel costruttore dell auto,
(in jva ci sarebbe un errore perceh non viene mai istanziato) ma nell xml mettiamo la dipendenza
di auto a motore

DIPENDENCIES INJECTION(Per metodo set)
mettiamo una proprieta nella classe auto (mappata nel xml beans)

DIPENDENCIES INJECTION(Per proprieta mappata)
mettiamo una proprieta nella classe auto motore (mappata nel xml beans) con riferimento interno 
al bean del motore

PROPRIETA' AUTOWIRE
Far decide in automatico al framework(contesto) quale iniezione di dipendenza utilizzare
Autowire possibili
-byName
-byType
-byConstructor

EREDITA' IN SPRING
parent="classe padre"

ARCHITETTURA APPLICATIVO SPRING

request -> Dispatcher servlet[controller] -> ModelAndView [fa da tramite tra il modello e la view che mostrerà l output]
						ViewResolver[componente che tramite una mappatura genera la view
DAO
//ROWMapper esegue un ciclo sul risultato dell esecuzione della select

JSTL
LIBRERIA DI TAG CUSTOM PER AGGIUNGERE FUNZIONALITA
Tramite dei tag lib è possibile richiamare funzionalita sugli oggetti, fromattazione sui dati

c : CORE -> contiene i paradigmi base senza utilizzare gli scriplet
fn : FORMAT -> format, formattare elementi interno alla pagina tramite funzini che modificano lo stato
di qualcosa (upperCase, json..)
fmt : contiene gli elementi di formattazione(date,numerici)
x : XML -> gestire il parsing di xml

<c:catch -> try/catch degli scriplet



IMPIEGATO CHE GUADAGNA DI PIU select * from impiegato where stipendio = (select max(stipendio) from impiegato);
IMPIEGATO CHE GUADAGNA DI PIU PER REPARTO
IMMAGINE IMPIEGATO


---------SPRING BOOT----------------------
Nasce per automattizare la creazione dell architettura

src/main/resources 
static -> risorse statiche(css,js,img)
templates -> risoluzione delle view(views del progetto precedente)
application.properties -> prop come server port, porta db

//errore classico: springboot cerca i componenti a partire dal pacchetto che abbiamo dato inizialmente

@Repository -> intrerffaccia che contiene metodi per operazioni crud
JpaRepository -> classico per tutti i rdbms

String... -> il metodo puo ricevere n argomenti
-------------------MYSQL--------------------

PASSWORD MYSQL root@localhost: qP;J)+Vpa8a#
mysqld -- console -> per attivaere il server
mysql -u root -p -> per entrare in connessione

MYSQL -> funziona con user
\G -> forza un allineamento in grid

---------------------------------------------
ORACLE DB
Con il termine database (d’ora in poi DB) si indicano i file fisici in cui sono memorizzati i dati, 
mentre per istanza si intende l’insieme delle aree di memoria e dei processi di background necessari ad accedere ai dati, ovvero al DB.
ISTANZA -> Sono i dati del db ch rispettano i vincoli imposti dallo schema.. Istantanea del db
SCHEMA -> uò avere più schemi. Ognuno di essi contiene tutti gli oggetti creati da un utente 
	specifico del database. Questi oggetti possono includere tabelle, viste, sinonimi e altro
TABLESPACE ->
-------------------------------------

----------------MongoDB-----------------------
> use contatti   --> switched to db contatti
> db  --> contatti

> db.dropDatabase()
> db.getUsers()

db.createUser(
{user:"turbo",
pwd:"pass",
roles:["readWrite","dbAdmin"]
});

> db.getCollectionNames()
> db.createCollection("contatti")
> db.contatto.find({$and: [{nome: 'Turbo'},{$or: [{cognome:'Rossi'},{username: 'ciccio'}]}]})
 db.contatto.update({username:'mimmo'},{$set:{
	... nome:'Ciccio',
	... cognome:'Fumagalli',
	... nascita: new Date(1998,1,1,3,2,12)}})

> db.contatto.find({},{nome:1, _id:0})
-------------------------------------------------

Optional -> involucro generico per un oggetto


-----------------NODE JS------------------------------
E' un server(molto simile a tomcat che compila lato server java),
che serve per compilare lato server javascript.. utilizza un compilatore di Google chrome,
particolarmente efficente.. 
input output asincrono -> fortemente basato su eventi
utile sia per applicazioni con frontend /backend  oppure solo per app tutto javascript


npm - node package manager
configuratore dell ambiente di sviluppo(es dipendenze)

npm install -g typescript (installiamo per tutti i progetti TypeScript)
TIPESCRIPT: permette di avere una tipizzazione forte, cosa che non ha javascript

npm install -g @angular/cli (installiamo la riga di comando di ANGULAR)
Per agggiornare ANGULAR CLI
npm install --save-dev @angular/cli@latest

REPL(READ EVAL P LOOP) 
npm install -g tsun 
-> tsun verifica codice javascript 
	es: 1 tsun
            2 function saluta(nome:string):string{return 100} 
	    3 ritorna errore perche ritorno deve essere string

-----------JAVASCRIPT-----------
compilato latp server (si puo creare backend) dunque con node js gira molto velocemente
compilato lato client - func che ineragiscono con DOM

DIFF: jsp linguaggio prettamente lato server, js il tutti e due

STORICO DELLE VERSIONI JS
ES5   ES6   TypeScript

-ECMAScript 5 -> regular JavaScrit(supportato da tutti i browser)
-ECMAScript 6 -> aggiornamento con l utilizzo di classi e moduli (OOP)
-TypeScript   -> gestione dei tipi
		-decorators(annotation in java, flag di funzionamento)
		-imports
		-utility i18n(internalizzazione dell applicazione)

------------------------------------------------------------------
dichiarazione var js -> var nome;
var nome = 'mimmo'; -> diventa stringa

ts -> var nome: string ;

function stampa(nome:string):string{
	return "Ciao" + nome;

TIPI DI DATO TYPESCRIPT
- var nome:string = 'turbo';
- var anni:number = 22;
- var laureato:boolean = true;
- var skills:Array<string> = ['asp','xml','java'];
- var skills:string[] = ['asp','xml','java'];
- enum Ruolo {IMPIEGATO, MANAGER, ASSISTENTE};
- var ruolo:Ruolo = Ruolo.IMPIEGATO;
- enum Ruolo2 {IMPIEGATO = 3, MANAGER = 5, ASSISTENTE = 7};
- var ruolo2:Ruolo = Ruolo2.3;

- var qualisiasi:any = 'Mimmo';
- qualsiasi = 1;
- qualsiasi = [1,2,3];

- function setNome(nome:string):void{
	this.nome = nome;
  }

STAMPA CONSOLE
system.out.print -> console.log(var);

DEFINIZIONE CLASSI (ES6 - TP)
- class:Impiegato{
	nome:string,
	cognome:string,
	compensoOrario:number;
	messaggio():void{
		console.log("Ciao ", this.nome);
	}
	calcoloStripendio(ore:number):number{
	return this.compensoOrario * ore;
	}
- var i: Impiegato;
- i = new Impiegato();
- i.nome = 'Max';
- i.compensoOrario = 30.00;
- i.messaggio();
- i.calcoloStipendio(10);

- class Auto{
  }
- var a = new Auto(); // costruttore implicito

class Persona{
	nome:string;
	cognome:string;
	eta:number;
	//costruttore puo essere solo uno
	constructor(nome:string, cognome:string, eta:number){
		this.nome = nome;
		this.cognome = cognome;
		this.eta = number;
	}
	messaggio(){
		console.log("Ciao" + this.nome);
	}
}

- var p:Persona = new Persona('mimmo','rossi',40);
 - p.messaggio();

class Stampa{
	dati:Array<string>;
	constructor(dati:Array<string>){
		this.dati = dati
	}
	esegui(){
		this.forEach(function(valore){
			console.log(valore);
			}
		);
	}
}

- var s:Stampa = new Stampa(['val1','val2',',val3']);
- s.esegui();

class StampaSpecializzata extends Stampa{
	intestazione:Array<string>;
	constructor(intestazione:string[], dati:string[]){
		super(dati);
		this.intestazione = intestazione;
	}
	esegui(){
		console.log(this.intestazione);
		super.esegui();
	}
}

- var intestazione:string[] = ['test'];
- var dati:string[] = ['val1','val2',',val3'];
- var specializzata: StampaSpecializzata = new StampaSpecializzata(intestazione,dati);
- specializzata.esegui();


------------------------------------------------
DICHIARAZIONE VARIABILI
- var nome:string;
- let nome:string;

function varTest(){  				function letTest(){
	var x = 10;					let x = 10;
	if(true){					if(true){
		var x = 30;					let x = 30;
		console.log(x);					console.log(x);
	}						}
	console.log(x);					console.log(x);
}						}

var -> SCOPE A LIVELLO DI FUNZIONE -> printa 30 e 30;
let -> SCOPE A LIVELLO DI BLOCCO -> printa 30 e 10;

var datix:string[] = ['val1','val2',',val3'];
datix.forEach(function(val){console.log(val);});
datix.forEach((val) => console.log(val));

- var nome:string = 'max';
- var cognome:string = 'rossi';
TEMPLATE SCRIPT
- var messaggio = 'Ciao ${nome} ${cognome}' 	NB: ' -> backtick ->alt 96


-------------CREAZIONE PROGETTO ANGULAR---------------------------------

- ng new NomeProgetto(y,n,css)
- cd NomeProgetto
- ng serve (compila il proj)
- localhost:4200
- visualstudiocode -> open folder NomeProgetto
- creiamo un component -> ng generate component messaggio

-----------------ANGULAR---------------------
Struttura nidificata di componenti 

-Che cos' un componente
 -app
	-app.component.ts -> descrive il funzionamento
		BINDING BIDIREZIONALE -> view che aggiorna, back che aggiorna
	-app.component.html -> view
	-app.component.css -> formattazione
	-app.component.spec.ts -> specifica il funzionamento di alcuni componenti
	-app.module.ts -> modulo di configurazione(dipendenze) [referenziare i componenti(obbligatorio)]

selector : identificativo che serve al linguaggio, per richiamare un componente

DECORATOR ANGULAR(TYPESCRIPT)
@Component({
  selector: 'app-root', 		-> quale elemento del dom deve essere utilizzato
  templateUrl: './app.component.html',  -> 
  styleUrls: ['./app.component.css']
})


COMPONENT ANGULAR
-> Elemento pricipale di angular 
	3 elementi
	-view .html
	-funzionamento - typescript .ts
	-formattazione .css

->componente inizializzati prima che venga chiamato -> init chiamato una volta

DIRETTIVA
- *ngFor

 @Input()nominativi:string[]; -> nominativi sara un valore preso come variabile


REGOLA JS
se creo funzioni di validazioni du form, o applicazioni monopagina
devo creare funzioni che ritornano boolean (in questo caso false)

backtik `

routes -> serve per definire i percorsi
RouterOutlet > componente placeholder, per posizionare il componente richiamato tramite la rotta
RouterLink > direttiva(messaggi che vengono inviati a node js per configurare il progetto) > fa da chiamata



BUILD PROGETTO PER DEPLOY

ng build --prod

PIPES -> strumenti per la formattazione html
	si riconoscono perche hanno nomePipe:tipo formattazione

	-Json 
	-Lowercase
	-Uppercase
	-Date
	-Currency
	-Percent
	-Decimal
	-Slice

DIRETTIVE -> sono dei messaggi che vengono inviati al node.js che servono per settare
	delle caratteristiche o funzionalita all interno della pagina html
	IF : 
		<div *ngIf="valore1 < val2"></div>
	NB: non permettere di mettere un else.. qundi bisogna  mettere la condizioe al
		contrario per poter lanciare l else
	
	SWITCH
		<div class="container" [ngSwitch] = "variabile">
			<div *ngSwitchCase='Max'>..</div>
			<div *ngSwitchCase='Max'>..</div>
			<div *ngSwitchCase='Max'>..</div>
			<div *ngSwitchDefault> <div>

	NGSTYLE:
	2 modi
	1:	<div [style.background-color] = "'red'"; (colore puo essere dinamico)
	2:	<div [ngStyle] = "{color: 'ivory', ...}">


ANGULAR FORMS
è un modulo interno con delgi automatismi

FORMCONTROLS
elemento di forms che serve per incapsulare gli input dei moduli
definisce l input in modo da agganciarlo in modo diretto con il componente
	SINGOLO CAMPO DI INPUT
NB CAMPSULANO LO STATO DEL CONTROL
	-> viene validato il dato 
	STATI
		->valid
		->invalid
		->pristine(mai stato istanziato)
		->dirty
		->errors

let nomeControl = new FormControl("max")
let nome = nomeControl.value;

FORM GROUP (insieme di form-controll(con i loro tai))

Validators
Observers

----------------------------------
TEMPLATE ANGULAR -> è la pagina html del componente

FORMCONTROLS
utilizza ngForm, ngModel

AppModuleTs : FormGrop
FormsModule -> permette di utilizzare direttive come ngModel, NgForm
ReactiveFormsModule -> formControl ngFormGroup


INTERPOLAZIONE -> associazione tra componente e view (binding dinamico)



DATA BINDING/INTERPOLAZIONE -> {{valore}}
	asincrono
	-bidirezionale (mi cambia sia il model che la view)
		[(ngModel)] = 'x'


PIPELINE -> utilizzta per contatenare una serie di operazioni da eseguire contemporaemente


---------------------OPEN SHIFT------------------------------

Open shift è una piattaforma di sviluppo per la distribuzione di container

Ogni applicativo per girare ha bisogno di un suo ambiente ad hoc
possibilità: o creo il server fisico cosi.. oppure virtualizzo

Problema? Prestazioni della macchina virtuale
Soluzione -> Ambiente DOCKER(container) - VIRTUALIZZAZIONE TRAMITE CONTAINER

CONTAINER -> Simile alla macchina virtuale
Com è fatto?

	Indirizzo Pubblico
	---------------------
	Ambiente
	---------------------
	Strato basso : Kernel
	
	Cloud (AWS,Azure) - Forniscono pacchetti di virtualizzazione 

Tolgo il problema di tirare in piedi un OS solo per un app,
SCOPO rendere il piu leggero possibile il deploy del progetto

Impacchetta tutte le dipendenze in modo tale da avere l app portabile

Per comunicare serve un ORCHESTRATORE - KUBERNATES: 
Gestisce i container
  -bilanciua il carico
	
	KUBERNATES
c1	c2	c3	c4

Kubernates -> Sviluppato da Google

OpenShift - Rilasciato da RedHat
Scopo: Tramite Kubernates gestire in maniera semplificata la gestione dei container,
	da la posssibilita agli sviluppatori di sfruttare tutte le potenzialità di kubernates

Prime attivita
 - ridimensionamento dei container(posso scalare l applicazione)
 - la creazione di progetti(deploy)
 - visualizzare registro
 - controllare i carichi(richieste/CPU)

-----------------------------------
OpenShift CommandLine(OP)
Scritta in Go

Operazioni svolte sia da console web sia da linea di comando

!!!!!!!!!!!!!!!
Source to Image (S2I)-> Strumento che permette di creare automaticamente container docker 
			tramite la lettura fatta del progetto sul git
	GIT -> S2I -> Docker(Immagine Virtualizzata)
Una volta utilizzato S2I bisogna utilizzare come Appserver WildFly

Log Error -> si possono leggere dalla console di prima

Per interagire con OpenShift:

- Project : Wrapper per i namespace
- Namespace : ambito delle risorse denominate, come l app deve essere distribuita dove sono contenuti:
- Gruppi
- Users

- Pod -> Container eseguiti sullo stesso host
	      condividono indirizzo IP
- Service -> Organizzatore dei pod : Quando io chiedo una connessione al servizio, OpSH mi instrada
		verso uno dei pod

-Route -> Elemento necessario per instradare la comunicazioen del servizio


Tutte le funzionalita openshift sono disponibili tramite un api rest

--------------------------------------------------------------------------

Webhook -> Chiamiamoli Trigger HTTP
	sono callback http scatenate direttamente dalle modifiche alle immagini e al codice sorgente

Replication Controller -> è tutto il meccanismo che gestice i pod creati






















